
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Ponavljanje za K1</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<link rel="stylesheet" href="css/prism-coy-all.css">
<script src="css/prism-coy-all.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="SPA_K1-priprema"
                  title="Ponavljanje za K1"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Uvod" duration="0">
        <p>ğŸ“Œ Primjer kolokvija iz prethodnih godina</p>
<h2 is-upgraded><strong>Opis</strong></h2>
<ul>
<li>Dobit Ä‡ete predloÅ¾ak konzolske aplikacije koji Ä‡e sadrÅ¾avati izbornik i kratke upute gdje se Å¡to piÅ¡e.</li>
<li>U predloÅ¾ak Ä‡e biti ukljuÄena i tekstualna datoteka s podacima.</li>
</ul>
<h2 is-upgraded><strong>SadrÅ¾aj kolokvija</strong></h2>
<h3 is-upgraded><strong>Strukture podataka</strong></h3>
<p>Prvi kolokvij sastoji se od linearnih struktura koje smo radili u prvom dijelu semestra:</p>
<ul>
<li>LinkedList&lt;&gt;</li>
<li>Dictionary&lt;&gt;</li>
<li>Hashtable</li>
</ul>
<p>Strukture stoga i reda nisu ukljuÄene jer Ä‡e biti ukljuÄene kasnije (kao dio algoritma pretrage grafova). Vezana lista nema kljuÄeve, a ostale dvije strukture imaju. Hashtable nema fiksne tipove vrijednosti (sve je <em>object</em>) dok ostale dvije imaju tipove definirane kod deklaracije.</p>
<h3 is-upgraded><strong>Zadaci</strong></h3>
<p>Kolokvij se sastoji od 5 zadataka, okvirno:</p>
<ol type="1">
<li>UÄitavanje i ispis podataka u neku od navedenih gotovih struktura, upravljanje duplikatima (ako je podrÅ¾ano).</li>
<li>Brisanje podataka iz strukture pod odreÄ‘enim uvjetom.</li>
<li><em>Nadogradnja</em> klase - dodavanje metoda u postojeÄ‡u klasu pomoÄ‡u <em>nasljeÄ‘ivanja</em>.</li>
<li>Implementacija vlastite strukture (klase) hash-tablice s kolizijom. RjeÅ¡avanje kolizije metodom ulanÄavanja ili bucket.</li>
<li>Prepoznavanje i primjena odgovarajuÄ‡e strukture podataka na zadani problem.</li>
</ol>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“– PredloÅ¡ci" duration="0">
        <h2 is-upgraded><strong>PredloÅ¾ak izbornika</strong></h2>
<p>Za vjeÅ¾bu napravite novi projekt i kopirajte odgovarajuÄ‡i kÃ´d u <strong>Program.cs</strong>. Pazite na namespace!</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System.Collections;

// pazite na namespace!
namespace SPA_K1_priprema_B;

class Program
{
    static void Main(string[] args)
    {
        // globalne varijable

        string izbor;
        do
        {
            Console.WriteLine(&#34;\nIZBORNIK:\n1. UÄitavanje podataka\n2a. Ispis\n2b. Brisanje\n3. TraÅ¾i\n4. Razvrstaj\n5. Zbrajanje\n0. Kraj rada&#34;);
            izbor = Console.ReadLine();

            switch (izbor)
            {
                case &#34;1&#34;:
                    Console.WriteLine(&#34;Unos&#34;);
                    break;
                case &#34;2a&#34;:
                    Console.WriteLine(&#34;Ispis&#34;);
                    break;
                case &#34;2b&#34;:
                    Console.WriteLine(&#34;Brisanje&#34;);
                    break;
                case &#34;3&#34;:
                    Console.WriteLine(&#34;TraÅ¾enje&#34;);
                    Console.Write(&#34;Unesi iznos: &#34;);
                    break;
                case &#34;4&#34;:
                    Console.WriteLine(&#34;Razvrstaj&#34;);
                    break;
                case &#34;5&#34;:
                    Console.WriteLine(&#34;Zbrajanje&#34;);
                    break;
                case &#34;0&#34;:
                    Console.WriteLine(&#34;Kraj&#34;);
                    break;
                default:
                    Console.WriteLine(&#34;GreÅ¡ka!&#34;);
                    break;
            }
        } while (izbor != &#34;0&#34;);

    }

}
</code></pre>
<h2 is-upgraded><strong>Primjer podataka</strong></h2>
<p>Dodajte tekstualnu datoteku sa sljedeÄ‡im testnim podacima:</p>
<p><code>podaci.txt</code></p>
<pre><code>Roxanne Cliett;68;5946,74
Dominique Mulvaney;49;8756,48
Letitia Letchworth;10;1595,74
Alex Brass;55;4099,07
Joycelyn Woolwine;70;8748,58
Letitia Letchworth2;10;1595,74
Laree Cavins;13;3586,83
Anna Alday;23;6413,08
Tommy Click;57;2292,24
Quinton Clever;32;7934,07
Albert Jetter;48;3721,3
Tommy Click2;57;2292,24
Letitia Letchworth3;10;1595,74
</code></pre>
<aside class="warning"><p><strong>Napomena:</strong> Ako vjeÅ¾bate na raÄunalu gdje su regionalne postavke drugaÄije (npr. US gdje se za decimale koristi <strong>toÄka</strong>, a ne <strong>zarez</strong>, onda prilagodite podatke. Na raÄunalima u uÄionici se koristi zarez za <strong>double</strong>.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak 1: Unos" duration="10">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>ProÄitati iz datoteke sve podatke o gostima hostela. Svaki <strong>gost</strong> ima:</p>
<ul>
<li>ime (ne treba razdvajati, npr. â€Roxanne Cliett&#34; se moÅ¾e spremiti u ime),</li>
<li>broj sobe,</li>
<li>iznos raÄuna.</li>
</ul>
<p>Broj sobe mora biti <strong>jedinstven</strong>, a tijekom rezervacije su se dogodile pogreÅ¡ke. Prednost Ä‡e u toj situaciji imati gosti koji su <strong>prvi rezervirali</strong>.</p>
<p>UÄitati podatke u strukturu Hashtable i ispisati tko je sve ostao bez rezervacije (ispisati ime i broj sobe) te koliko je gostiju uspjeÅ¡no upisano.</p>
<p>Neka korisnik unosi naziv datoteke.</p>
<h2 is-upgraded><strong>Prijedlog rjeÅ¡enja</strong></h2>
<p>Obzirom na navedene podatke, potrebno je definirati klasu <strong>Gost</strong>. MoÅ¾ete pisati jedan ili viÅ¡e konstruktora (ili ne).</p>
<p><code>Gost.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace pomocna
{
    class Gost
    {
        //Roxanne Cliett;68;5946,74
        public string ime;
        public int brojSobe;
        public double racun;

        // 4.
        public Gost next;
        public Gost(string imep, int brojSobep, double racunp)
        {
            this.ime = imep;
            this.brojSobe = brojSobep;
            this.racun = racunp;
        }
        public Gost()
        {}
    }
}
</code></pre>
<p>Gore se koristi <strong>namespace</strong> pod nazivom <strong>pomocna</strong>, Å¡to se ne poklapa s imenskim prostorom u <strong>Program.cs</strong>. Ne morate tako raditi, moÅ¾ete jednostavno kopirati isti namespace.</p>
<h3 is-upgraded><strong>Glavni dio</strong></h3>
<p>U ovom primjeru, rjeÅ¡eno je tako da je napisana posebna metoda <strong>Unos()</strong>, premda se to nije traÅ¾ilo u zadatku pa prema tome <strong>nije bilo obavezno</strong>. Napisano je tako samo zbog preglednosti.</p>
<aside class="special"><p>âœ… Nakon unosa, nije loÅ¡e provjeriti u glavnom programu broj upisanih elemenata (Äak i ako ne piÅ¡e u zadatku) kako nam se ne bi potkrala pogreÅ¡ka da struktura ostane zapravo prazna.</p>
</aside>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">case &#34;1&#34;:
    Console.WriteLine(&#34;Unos&#34;);
    Unos(ht);
    // obavezno ispisati nakon unosa, za provjeru!
    Console.WriteLine(&#34;Upisano: &#34; + ht.Count);
    break;
</code></pre>
<p>Ne zaboravite deklarirati varijablu tipa <strong>Hashtable</strong> u glavnom dijelu programa (negdje van izbornika):</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">// globalne varijable
Hashtable ht = new Hashtable();
</code></pre>
<p>Metoda za unos:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">private static void Unos(Hashtable ht)
{
    // za ÄiÅ¡Ä‡enje postojeÄ‡ih elemenata preporuka je napraviti Clear()
    ht.Clear();
    Console.Write(&#34;Unesite ime datoteke: &#34;);
    string imeDat = Console.ReadLine();
    if (!File.Exists(imeDat))
    {
        Console.WriteLine(&#34;Datoteka ne postoji!&#34;);
        return;
    }
    using (StreamReader sr = new StreamReader(imeDat))
    {
        string linija;
        while ((linija = sr.ReadLine()) != null)
        {
            //Roxanne Cliett;68;5946,74
            string[] s = linija.Split(&#39;;&#39;);
            Gost novi = new Gost();
            novi.ime = s[0];
            novi.brojSobe = int.Parse(s[1]);
            novi.racun = double.Parse(s[2]);

            if (ht.ContainsKey(novi.brojSobe))
            {
                Console.WriteLine($&#34;Dupli: {novi.ime} / {novi.brojSobe}&#34;);
            }
            else
            {
                ht.Add(novi.brojSobe, novi);
            }
        }
    }

}
</code></pre>
<p>Ovdje treba malo pripaziti! Naime, ako na poÄetku metode za unos instancirate novi objekt tipa <strong>Hashtable</strong>, a veÄ‡ ste poslali <strong>referencu</strong> kao parametar, onda Ä‡e se uniÅ¡titi postojeÄ‡a referenca te se podaci <strong>neÄ‡e spremiti</strong> u glavnu varijablu <strong>ht</strong>.</p>
<p>Zato nam je dobra kontrola - ispis broja elemenata. RjeÅ¡enje je kao gore, koristiti <strong>Clear()</strong> na istoj referenci (objektu) ili proslijediti ht pomoÄ‡u kljuÄne rijeÄi <strong>ref</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak 2: Ispis &#43; brisanje" duration="10">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p><strong>a) Ispis</strong></p>
<p>Ispisati sve podatke iz <strong>Hashtable</strong> strukture na konzolu.</p>
<p><strong>b) Brisanje</strong></p>
<p>Korisnik unosi veliko poÄetno slovo imena. Ako postoje gosti s tim poÄetnim slovom, izbrisati ih. Ispisati koliko je gostiju izbrisano.</p>
<p>Provjeriti ponovnim pozivanjem ispisa jesu li izbrisani!</p>
<h2 is-upgraded><strong>Prijedlog rjeÅ¡enja</strong></h2>
<h3 is-upgraded><strong>Ispis</strong></h3>
<p>Za ispis opet moÅ¾emo (i ne moramo) koristiti metodu. Primjer:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">private static void Ispis(Hashtable ht)
{
    foreach (int kljuc in ht.Keys)
    {
        Gost g = (Gost)ht[kljuc];
        Console.WriteLine($&#34;{g.ime} {g.brojSobe} {g.racun} eur&#34;);
    }
}
</code></pre>
<p>Metoda je opet <strong>statiÄka</strong>, kao Å¡to je to i <strong>Main</strong>. Å aljemo joj objekt tipa <strong>Hashtable</strong> te pomoÄ‡u <strong>foreach</strong> petlje ispisujemo sadrÅ¾aj.</p>
<aside class="special"><p>âœ… Sve Å¡to se nalazi u <strong>Hashtable</strong> je tipa <strong>object</strong> pa moramo raditi pretvorbu pomoÄ‡u <strong>cast</strong> operatora.</p>
</aside>
<h3 is-upgraded><strong>Brisanje</strong></h3>
<p>Za brisanje je potrebno upisati Å¡to Å¾elimo brisati te brisanje provodimo u dvije faze:</p>
<ul>
<li>Prikupljanje kljuÄeva po kriteriju iz zadatka (jer hashtable ima kljuÄeve i briÅ¡e po njima)</li>
<li>Brisanje po prikupljenim kljuÄevima</li>
</ul>
<p>Opet je napisana metoda (iako se nije traÅ¾ila).</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">private static void Brisanje(Hashtable ht)
{
    Console.Write(&#34;UpiÅ¡ite veliko slovo: &#34;);
    // moÅ¾e biti greÅ¡ka, kad?
    char slovo = char.Parse(Console.ReadLine());
    List&lt;int&gt; brisi = new List&lt;int&gt;();
    foreach (int kljuc in ht.Keys)
    {
        Gost g = (Gost)ht[kljuc];
        if (g.ime[0] == slovo)
            brisi.Add(g.brojSobe);
    }
    foreach (int br in brisi)
    {
        ht.Remove(br);
    }
    Console.WriteLine(&#34;Pobrisano: &#34; + brisi.Count);
}
</code></pre>
<p>Pogledajmo u glavnom dijelu za oba problema iz ove toÄke:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">case &#34;2a&#34;:
    Console.WriteLine(&#34;Ispis&#34;);
    Ispis(ht);
    break;
case &#34;2b&#34;:
    Console.WriteLine(&#34;Brisanje&#34;);
    Brisanje(ht);
    break;
</code></pre>
<p>U gornjem pristupu pitamo korisnika Å¡to Å¾eli brisati unutar same metode (kako bi glavni dio programa bio joÅ¡ pregledniji).</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak 3: Nadogradnja" duration="10">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p><strong>Nadograditi</strong> klasu iz prethodnih toÄaka (misli se na <strong>Hashtable</strong>) tako da joj dodate metodu:</p>
<ul>
<li><strong>TraziGoste()</strong> koja <strong>prima broj</strong>, a <strong>vraÄ‡a popis gostiju</strong> koji imaju iznos raÄuna manji od unesenog.</li>
<li>Korisnik unosi iznos u glavnom programu, na konzolu se ispisuje ukupan broj pronaÄ‘enih, imena i iznos za svakoga.</li>
</ul>
<h2 is-upgraded><strong>Prijedlog rjeÅ¡enja</strong></h2>
<aside class="warning"><p><strong>VaÅ¾no!</strong> Ovdje morate shvatiti da metoda <strong>mora biti nadograÄ‘ena</strong> (koristi se nasljeÄ‘ivanje) te se <strong>neÄ‡e priznati</strong> statiÄka metoda napisana na isti naÄin kao gornje metode za ispis i brisanje.</p>
</aside>
<p>Dakle, piÅ¡emo <strong>novu klasu!</strong> Nazovimo je <strong>MojaHT</strong>.</p>
<p><code>MojaHT.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System.Collections;

namespace pomocna
{
    class MojaHT : Hashtable
    {
    }
}
</code></pre>
<p>DvotoÄka iza naziva <strong>MojaHT</strong> znaÄi da ta klasa nasljeÄ‘uje <strong>sve</strong> Å¡to <strong>Hashtable</strong> ima te samo dodajemo novu metodu.</p>
<p>VeÄ‡ nakon ovog moÅ¾emo zamijeniti naÅ¡u deklaraciju:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">// globalne varijable
MojaHT ht = new MojaHT();
</code></pre>
<p>RjeÅ¡enje:</p>
<p><code>MojaHT.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System.Collections;

namespace pomocna
{
    class MojaHT : Hashtable
    {
        public List&lt;Gost&gt; TraziGoste(double iznos)
        {
            List&lt;Gost&gt; tr = new List&lt;Gost&gt;();

            foreach (int kljuc in this.Keys)
            {
                Gost g = (Gost)this[kljuc];
                if (g.racun &lt; iznos)
                {
                    tr.Add(g);
                }
            }

            return tr;
        }
    }
}
</code></pre>
<aside class="warning"><p><strong>VaÅ¾no!</strong> UoÄite gdje se koristi kljuÄna rijeÄ <strong>this</strong>. Ponovite Äemu ona sluÅ¾i!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak 4: Hashtable s kolizijom" duration="10">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Napravite <strong>strukturu podataka</strong> (posebnu klasu) po principu <strong>hashtablice s kolizijom</strong> koja Ä‡e razvrstavati goste po duljini imena.</p>
<ul>
<li>Klasa mora imati hash funkciju koja se koristi za razvrstavanje po duljini imena.</li>
<li>Maksimalni broj dÅ¾epova (kategorija) je 11.</li>
<li>Ispisati podatke iz te strukture ih tako da se ispiÅ¡e broj dÅ¾epa, te ispod svakog broja imena koja su tu spremljena.</li>
</ul>
<h2 is-upgraded><strong>Prijedlog rjeÅ¡enja</strong></h2>
<p>Ovdje je potrebno napisati cijelu novu klasu, nazovimo je <strong>PosebnaHT</strong> koja radi po pravilima.</p>
<p><code>PosebnaHT.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace pomocna
{
    class PosebnaHT
    {
        private Gost[] popis;
        public PosebnaHT()
        {
            popis = new Gost[11];
        }

        public void Dodaj(Gost novi)
        {
            
        }

        public string Ispis()
        {
            string s = &#34;&#34;;

            return s;
        }

    }
}
</code></pre>
<p>Klasa ima <strong>public</strong> metode za dodavanje i ispis te polje <strong>popis</strong> koje je niz. Niz Ä‡e imati 11 elemenata prema uputama u zadatku.</p>
<h3 is-upgraded><strong>Hash metoda</strong></h3>
<p>Klasa ima hash metodu (funkciju) koja raÄuna poziciju:</p>
<p><code>PosebnaHT.cs</code></p>
<pre><code language="language-cs" class="language-cs">private int Hash(Gost g)
{
    int poz = g.ime.Length % 11;
    return poz;
}
</code></pre>
<p>MoÅ¾e biti <strong>private</strong> jer nije potrebna van klase, ali niÅ¡ta se neÄ‡e dogoditi i ako ostane <strong>public</strong>.</p>
<h3 is-upgraded><strong>Metoda za dodavanje elemenata</strong></h3>
<p>Metoda <strong>Dodaj()</strong> prima gosta te na temelju podataka raÄuna poziciju (prema uputama iz zadatka). Instanciranjem niza <strong>popis</strong>, zadane vrijednosti svih elemenata niza su <strong>null</strong>. Ako je element null, onda znaÄi da tu nismo joÅ¡ niÅ¡ta dodali te Ä‡emo spremiti novi element.</p>
<p>Ako nije null, onda se dogodila <strong>kolizija</strong> koju Ä‡emo u ovom primjeru rijeÅ¡iti na naÄin s <strong>ulanÄavanjem</strong> tako da:</p>
<ul>
<li>Dodamo novo polje <strong>next</strong> u klasu <strong>Gost</strong>,</li>
<li>Zatim &#34;zakaÄimo&#34; novi element (koji je doÅ¡ao u koliziju) na kraj (kao Å¡to smo to radili kod redova i naÅ¡ih vezanih listi na ranijim vjeÅ¾bama).</li>
</ul>
<p><code>PosebnaHT.cs</code></p>
<pre><code language="language-cs" class="language-cs">public void Dodaj(Gost novi)
{
    int i = Hash(novi);
    if (popis[i] == null)
    {
        popis[i] = novi;
    }
    else
    {
        Gost temp = popis[i];
        while (temp.next != null)
            temp = temp.next;
        temp.next = novi;
    }
}
</code></pre>
<p>Ispis u ovom sluÄaju piÅ¡emo kako smo navikli na vjeÅ¾bama, bez spominjanja konzole veÄ‡ spremanjem u string kako naÅ¡a klasa ne bi ovisila o suÄelju u kojem radimo aplikaciju (nije nuÅ¾no za kolokvij!):</p>
<p><code>PosebnaHT.cs</code></p>
<pre><code language="language-cs" class="language-cs">public string Ispis()
{
    string s = &#34;&#34;;

    for (int i = 0; i &lt; popis.Length; i++)
    {
        s += &#34;Duljina: &#34; + i + &#34;\n&#34;;
        Gost temp = popis[i];
        while (temp != null)
        {
            s += &#34; &#34; + temp.ime + &#34;\n&#34;;
            temp = temp.next;
        }
    }

    return s;
}
</code></pre>
<p>Ovdje umjesto ovog pristupa jednostruke vezane liste moÅ¾ete koristiti niz listi ili niz redova ili...</p>
<p>U glavnom dijelu programa piÅ¡emo:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">case &#34;4&#34;:
    Console.WriteLine(&#34;Razvrstaj&#34;);
    PosebnaHT pht = new PosebnaHT();
    // proÅ¡etamo se po postojeÄ‡oj ht
    foreach (int k in ht.Keys)
    {
        // dodajemo u novu
        pht.Dodaj((Gost)ht[k]);
    }
    Console.WriteLine(pht.Ispis());
    break;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak 5: Primjena" duration="10">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Za svako poÄetno slovo imena gosta koje postoji u hashtable strukturi ispisati koliko je ukupno potroÅ¡eno (sve raÄune).</p>
<ul>
<li>Za rjeÅ¡enje iskoristite bilo koju od struktura podataka koju smo radili na SPA.</li>
<li>Neka se slova koja postoje u datoteci ispisuju poredana po abecedi.</li>
</ul>
<h2 is-upgraded><strong>Prijedlog rjeÅ¡enja</strong></h2>
<p>Ovdje moramo prepoznati sljedeÄ‡e:</p>
<ul>
<li>TraÅ¾i se brojanje po stvarima za koje ne znamo koliko ih ima, ne moÅ¾e biti niz niti lista â‡’ Dictionary.</li>
<li>NeÄ‡emo koristiti <strong>Hashtable</strong> jer Å¾elimo izbjeÄ‡i stalnu pretvorbu tipova.</li>
<li>TraÅ¾i se neÅ¡to sortirano â‡’ klasa koja je sortirana, a to je <strong>SortedDictionary&lt;&gt;</strong> koji takoÄ‘er ima tipove jer znamo da se Dictionary <strong>ne moÅ¾e sortirati</strong>.</li>
<li>MoÅ¾emo i ne moramo raditi posebnu metodu (ovdje nismo, ali je glavni <strong>case</strong> malo nepregledan).</li>
</ul>
<p>Koristimo parove:</p>
<ul>
<li>KljuÄ je slovo</li>
<li>Vrijednost je <strong>double</strong> tj. ukupan zbroj vrijednosti koje pripadaju tom slovu.</li>
</ul>
<p>Kad prvi put naiÄ‘emo na neko slovo, samo spremimo par (slovo i iznos). Svaki sljedeÄ‡i put, dodajemo novi iznos raÄuna na postojeÄ‡e stanje.</p>
<p>Na kraju, napravimo iteraciju po dodanim slovima i ispiÅ¡emo vrijednosti.</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">case &#34;5&#34;:
    Console.WriteLine(&#34;Zbrajanje&#34;);
    SortedDictionary&lt;char, double&gt; z = new SortedDictionary&lt;char, double&gt;();
    foreach (int kljuc in ht.Keys)
    {
        Gost g = (Gost)ht[kljuc];
        char slovo = g.ime[0];
        if (z.ContainsKey(slovo))
        {
            // dodaj na postojeÄ‡e
            z[slovo] += g.racun;
        }
        else
        {
            // prvi put
            z.Add(slovo, g.racun);
        }
    }

    foreach (char k in z.Keys)
    {
        Console.WriteLine($&#34;{k}: {z[k]} eur&#34;);
    }

    break;
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Za kraj" duration="0">
        <p>Nemojte nauÄiti ovo rjeÅ¡enje napamet jer ima viÅ¡e naÄina na koje se to moÅ¾e rijeÅ¡iti te isto tako viÅ¡e oblika zadataka.</p>
<p>Planirano vrijeme pisanja: 60 minuta.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
