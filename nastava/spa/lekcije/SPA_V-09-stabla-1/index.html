
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>SPA: Stabla</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<link rel="stylesheet" href="css/prism-coy-all.css">
<script src="css/prism-coy-all.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="SPA_V-09-stabla-1"
                  title="SPA: Stabla"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Uvod" duration="0">
        <p>ğŸ“Œ Stabla</p>
<p>ğŸ“Œ Binarna ureÄ‘ena stabla za pretraÅ¾ivanje</p>
<p>ğŸ“Œ Operacije unosa i ispisa (obilaska) binarnog ureÄ‘enog stabla</p>
<h2 is-upgraded><strong>Osnovni pojmovi</strong></h2>
<p>ÄŒesto moramo opisati grupu objekata iz stvarnog svijeta koje su meÄ‘usobno povezane, a to</p>
<p>ne moÅ¾emo napraviti linearnim strukturama koje smo radili do sad. Za takve situacije, pomaÅ¾u <strong>razgranate strukture</strong>. Razgranatim strukturama podataka ovdje smatramo grafove i podvrste grafova (npr. stabla). Razgranata struktura <strong>stablo</strong> (eng. tree) sastoji se od <strong>Ävorova</strong> (eng. nodes) koji mogu biti povezani s ostalim elementima. Stabla predstavljaju hijerarhijske strukture gdje je vaÅ¾no Å¡to je na kojoj razini, dok su grafovi opÄ‡enitije strukture koje mogu predstavljati drugaÄije probleme (npr. mapa grada i sl.).</p>
<p>Stablo u programiranju ima:</p>
<ul>
<li>Korijen</li>
<li>Listove</li>
<li>ÄŒvorove</li>
<li>Veze</li>
</ul>
<p>Vizualiziramo ga obrnuto u odnosu na prirodu jer korijen uvijek crtamo na vrhu.</p>
<table>
<tr><td colspan="1" rowspan="1"><p><img src="img/b0eec0b2fe7c43e7.png">Stablo u prirodi</p>
</td><td colspan="1" rowspan="1"><p><img src="img/6ab33148ac5e84b5.png">Stablo u programiranju</p>
</td><td colspan="1" rowspan="1"><p class="image-container"><img src="img/e4f6bd24ff3790a7.png"></p>
</td></tr>
</table>
<p><strong>Korijen</strong> predstavlja Ävor koji nema <strong>roditelja</strong>. <strong>List</strong> je Ävor koji nema djece. Sve ostale Ävorove (koji nisu ni korijen ni list) nazivamo <strong>unutarnjim Ävorovima</strong>.</p>
<p><strong>Putanja</strong> (eng. path) predstavlja niz Ävorova povezanih bridovima (vezama) bez ponavljanja. Duljina putanje je broj bridova koji povezuju te Ävorove. Ponekad nam je u zadacima lakÅ¡e prebrojati Ävorove koje smo proÅ¡li.</p>
<h2 is-upgraded><strong>Binarna stabla</strong></h2>
<p>Binarno stablo je stablo u kojem Ävorovi imaju <strong>najviÅ¡e dvoje djece</strong>. Obzirom da postoji samo dvoje djece, onda ih zovemo <em>lijevo</em> i <em>desno</em> dijete. Ta djeca su korijeni lijevog i desnog podstabla. Neki Ävorovi mogu imati samo lijevo ili samo desno dijete, a neki mogu biti bez djece, te se kao i kod opÄ‡enitih stabala nazivaju <em>listovi</em>.</p>
<aside class="special"><p>ÄŒvor binarnog stabla je binarno stablo koje moÅ¾e imati lijevo i desno dijete, a ta djeca su takoÄ‘er binarna stabla.</p>
</aside>
<p class="image-container"><img alt="dc27c7b489e74782.png" style="width: 566.60px" src="img/dc27c7b489e74782.png"></p>
<p>Kod binarnih stabala, vaÅ¾no je razlikovati lijevu i desnu stranu. Binarna stabla sa slike su potpuno razliÄita:</p>
<p class="image-container"><img alt="b0be8a03db3abd6d.png" style="width: 306.00px" src="img/b0be8a03db3abd6d.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Binarno stablo za pretraÅ¾ivanje" duration="0">
        <p>Binarno stablo za pretraÅ¾ivanje (eng. Binary Search Tree, <strong>BST</strong>) ili ureÄ‘eno binarno stablo predstavlja stablo u kojem je jasno definiran ureÄ‘aj, odnosno naÄin rasporeda elemenata u stablu, ukratko:</p>
<ul>
<li>Korijen je prvi Ävor koji nema roditelja,</li>
<li>Stablo moÅ¾e imati 0, 1 ili 2 djece,</li>
<li>ÄŒvor (dijete) s lijeve strane ima vrijednost koja je <strong>manja</strong> od vrijednosti roditelja</li>
<li>ÄŒvor (dijete) s desne strane ima vrijednost koja je <strong>veÄ‡a</strong> od vrijednosti roditelja</li>
</ul>
<p>UreÄ‘ena binarna stabla mogu koristiti jedinstveni identifikacijski kljuÄ u svakom Ävoru. VaÅ¾no svojstvo kljuÄeva je da su usporedivi.</p>
<aside class="special"><p>Za dva objekta A i B kaÅ¾emo da su usporedivi ako vrijedi toÄno jedno od sljedeÄ‡eg:</p>
<ul>
<li>A je manji od B</li>
<li>A je veÄ‡i od B</li>
<li>A je jednak B.</li>
</ul>
</aside>
<p>ÄŒvorovi mogu sadrÅ¾avati razliÄite vrijednosti osim identifikacijskog kljuÄa, ali kljuÄ mora biti jedinstven kako bi mogli doÄ‡i do traÅ¾enog Ävora.</p>
<p>Na slici vidimo primjer takvog stabla.</p>
<p class="image-container"><img alt="2f74e14bb8ff71b.png" style="width: 414.67px" src="img/2f74e14bb8ff71b.png"></p>
<aside class="special"><p><strong>Definicija:</strong></p>
<p>UreÄ‘eno binarno stablo (ili binarno stablo za pretraÅ¾ivanje) je binarno stablo u kojem svaki Ävor ima jedinstveni kljuÄ, svaka dva kljuÄa su usporediva, a stablo je organizirano tako da za svaki Ävor t vrijedi:</p>
<ul>
<li>Svi kljuÄevi u lijevom podstablu Ävora t su manji od njegovog kljuÄa</li>
<li>Svi kljuÄevi u desnom podstablu Ävora t su veÄ‡i od njegovog kljuÄa.</li>
</ul>
</aside>
<p>Prema tome, vrlo lako moÅ¾emo doÄ‡i do najmanjeg ili najveÄ‡eg kljuÄa. Ako stablo nije prazno, najmanja vrijednost kljuÄa nalazi se u krajnjem lijevom Ävoru (ako postoji), a ako takav ne postoji onda se nalazi u korijenu. Analogno, ako stablo nije prazno, najveÄ‡a vrijednost kljuÄa nalazi se u krajnjem desnom Ävoru, a ako takav ne postoji onda je u korijenu.</p>
<h2 is-upgraded><strong>Osnovne operacije</strong></h2>
<p>Osnovne operacije u binarnom ureÄ‘enom stablu su:</p>
<ul>
<li><strong>Dodavanje</strong> elemenata,</li>
<li><strong>TraÅ¾enje</strong> elemenata,</li>
<li><strong>Brisanje</strong> elemenata.</li>
</ul>
<p>Dodavanje ili umetanje novog elementa u binarno ureÄ‘eno stablo znaÄi dodati novi element tako da stablo i dalje ostane <strong>ureÄ‘eno</strong>. Prema tome, potrebno je pronaÄ‡i poziciju na koju moÅ¾emo smjestiti novi element.</p>
<p>Dodavanje obavljamo u dvije faze:</p>
<ol type="1">
<li>Ako je stablo prazno, dodaj novi element na mjesto korijena.</li>
<li>Ako stablo nije prazno, usporedi vrijednost kljuÄa te ako je novi element manji, smjesti ga u lijevo podstablo, ako je veÄ‡i u desno podstablo.</li>
</ol>
<p>Gore nedostaje opis Å¡to se dogaÄ‘a ako je novi kljuÄ jednak veÄ‡ postojeÄ‡em. Najjednostavnije je takve situacije ignorirati, ali Äesto Å¾elimo znati da su se dogodile.</p>
<p>Iz gornjeg opisa dodavanje novih elemenata, moÅ¾emo zakljuÄiti kako je algoritam rekurzivan, no kod dodavanja nije nuÅ¾no pisati rekurziju jer je Äesto teÅ¾e razumljiva poÄetnicima pa Ä‡emo ÄeÅ¡Ä‡e u zadacima problem rjeÅ¡avati petljom.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Obilasci stabla" duration="0">
        <p>Obilazak (eng. traversal) binarnog ureÄ‘enog stabla je Äest problem u programiranju. Ovdje Ä‡emo koristiti jedan od tri naÄina obilaska koji kreÄ‡u od korijena:</p>
<ul>
<li><strong>In-order (Lijevo - Korijen - Desno)</strong> - algoritam najprije obilazi lijevo podstablo, zatim korijen pa onda desno podstablo,</li>
<li><strong>Pre-order (Korijen - Lijevo - Desno)</strong> - algoritam najprije obilazi korijen, zatim lijevo podstablo pa onda desno podstablo,</li>
<li><strong>Post-order (Lijevo - Desno - Korijen)</strong> - algoritam najprije obilazi lijevo postablo, zatim desno podstablo pa korijen.</li>
</ul>
<p>Za primjer stabla sa slike:</p>
<p class="image-container"><img alt="b6f0466367b074f8.png" style="width: 472.67px" src="img/b6f0466367b074f8.png"></p>
<p>U prvom koraku algoritam promatra lijevo podstablo:</p>
<p class="image-container"><img alt="9f50c0691131719b.png" style="width: 189.33px" src="img/9f50c0691131719b.png"></p>
<p>Na njega primjenjujemo L-K-D: 15, 25, 30, Äime je lijevo podstablo obraÄ‘eno.</p>
<p>Nakon Å¡to je gotovo, onda se ispisuje glavni korijen s prethodne slike: 50 i prelazimo na desno podstablo te kako s lijeve strane nema niÅ¡ta, ispisujemo 70 i 81, odnosno sve skupa je:</p>
<p>15, 25, 30 50, 70, 81.</p>
<p>PokuÅ¡ajte sami na papiru rijeÅ¡iti ostala dva obilaska na ovom primjeru!</p>


      </google-codelab-step>
    
      <google-codelab-step label="ÄŒvor binarnog ureÄ‘enog stabla" duration="0">
        <p>Definiramo Ävor binarnog ureÄ‘enog stabla kao klasu koja sadrÅ¾i polja (ili po potrebi svojstva):</p>
<ul>
<li>Vrijednost (informacije koje Å¾elimo spremiti)</li>
<li>KljuÄ (podatak koji Ä‡e biti jedinstven) - temelj za ureÄ‘aj u stablu</li>
<li>Reference na lijevo i desno dijete</li>
</ul>
<p>Vrijednost i kljuÄ se mogu poklopiti (ako bi primjerice spremali samo jedinstvene realne brojeve), ali to je jako jednostavan sluÄaj.</p>
<p>Klasu <strong>Cvor</strong> moÅ¾emo i ne moramo pisati u zasebnoj datoteci:</p>
<p><code>Cvor.cs</code></p>
<pre><code language="language-cs" class="language-cs">class Cvor
{
    public int broj; //jedinstveni kljuÄ
    public Cvor lijevo, desno;
    public Cvor(int br)
    {
        this.broj = br;
        this.lijevo = null;
        this.desno = null;
    }
}
</code></pre>
<p>U gornjoj implementaciji, imamo samo broj kao sadrÅ¾aj. Napisan je i konstruktor koji prima vrijednost (odnosno broj).</p>
<p>Zadane vrijednosti za polja koja su objekti je <strong>null</strong>, no ne smeta nam ako to napiÅ¡emo eksplicitno jer nam je tako jasnije.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Klasa BinarnoStablo" duration="0">
        <p>Definiramo posebnu klasu pod nazivom <strong>BinarnoStablo</strong>. Klasa se sastoji od polja koje predstavlja <strong>korijen</strong> te metoda koje Ä‡emo koristiti za razliÄite operacije.</p>
<p><code>BinarnoStablo.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
namespace bibStablo
{
    class BinarnoStablo
    {
        public Cvor korijen;
        public void Dodaj(int br)
        {

        }

        public void Ispis()
        {

        }

    }
}
</code></pre>
<p>Korijen je u gornjem sluÄaju <strong>public</strong> tako da ga moÅ¾emo pozvati i iz glavnog programa, no bilo bi bolje da je zapravo <em>private</em> kako bi se rad s podacima kontrolirao iskljuÄivo pomoÄ‡u metoda koje pripadaju klasi.</p>
<h2 is-upgraded><strong>Dodavanje elemenata u BST</strong></h2>
<p>Dalje u tekstu Ä‡emo BST kraÄ‡e nazivati samo &#34;binarno stablo&#34;.</p>
<p>Metodu za dodavanje elemenata u binarno stablo moÅ¾emo pisati na dva naÄina:</p>
<ul>
<li>PomoÄ‡u petlje</li>
<li>PomoÄ‡u rekurzije</li>
</ul>
<p>Ideja je sliÄna kao kod vezane liste:</p>
<ul>
<li>Ako je prazno, novi Ävor spremi kao korijen</li>
<li>Ako nije prazno, traÅ¾i prvo slobodno mjesto lijevo ili desno (prema pravilima).</li>
</ul>
<p>Metoda takoÄ‘er moÅ¾e primati:</p>
<ul>
<li>ÄŒvor</li>
<li>Vrijednost</li>
</ul>
<p>Povratna vrijednost metode moÅ¾e biti:</p>
<ul>
<li>NiÅ¡ta (void) - ako nije potrebna povratna informacija,</li>
<li>Bool - npr. <strong>true</strong>, je dodavanje bilo uspjeÅ¡no ili <strong>false</strong> ako nije,</li>
<li>String - npr. poruka zaÅ¡to dodavanje nije uspjelo ili s koje strane je dodan element,</li>
<li>Int - koliko koraka je bilo potrebno za dodati element i sl.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Dodavanje elemenata - while" duration="0">
        <p>Napisat Ä‡emo metodu za dodavanje koja radi s petljom.</p>
<p><code>BinarnoStablo.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
namespace bibStablo
{
    class BinarnoStablo
    {
        public Cvor korijen;

        public void Dodaj(int br)
        {
            Cvor novi = new Cvor(br);
            // 1. ako je stablo prazno
            if (korijen == null)
            {
                korijen = novi;
                return;
            }

            // 2. ako nije prazno
            Cvor temp = korijen;
            while (true)
            {
                // provjeri sve tri moguÄ‡nosti
                if (novi.broj &lt; temp.broj)
                {
                    // vidi je li lijevo prazno
                    if (temp.lijevo == null)
                    {
                        temp.lijevo = novi;
                        return; //gotovo
                    }
                    else
                        temp = temp.lijevo; // idi dalje
                }
                else if (novi.broj &gt; temp.broj)
                {
                    // vidi je li desno prazno
                    if (temp.desno == null)
                    {
                        temp.desno = novi;
                        return; //gotovo
                    }
                    else
                        temp = temp.desno; // idi dalje
                }
                else
                {
                    // ako su jednaki
                    return;
                }
            }
        }       
    }
}
</code></pre>
<p>U gornjem rjeÅ¡enju, petlja je beskonaÄna (uvjet <strong>true</strong>), ali je predviÄ‘eno da se petlja prestane izvrÅ¡avati (pomoÄ‡u naredbe <strong>break</strong> ili <strong>continue</strong>) kad se novi element uspjeÅ¡no smjesti ili ako novi element ima dupli kljuÄ (u gornjem primjeru broj).</p>
<aside class="warning"><p>ğŸ“Œ</p>
<p>Problem je Å¡to vrlo lako moÅ¾ete previdjeti jednu od moguÄ‡ih &#34;grana&#34; u odlukama (if-ovima), a u tom sluÄaju petlja postaje beskonaÄna.</p>
</aside>
<p>Primjer: ako su kljuÄevi jednaki, ne mora se raditi niÅ¡ta.</p>
<p>MoÅ¾da se Äini kako je lako uoÄiti beskonaÄnu petlju, ali u tom sluÄaju morate imati dobre testne podatke.</p>
<h2 is-upgraded><strong>Ispis</strong></h2>
<p>Kako bi mogli testirati gornji program (metodu za dodavanje), potrebna nam je posebna metoda kojom Ä‡emo ispisati sadrÅ¾aj. Obzirom da ne znamo koliko na kojoj grani moÅ¾e biti elemenata, onda moramo obiÄ‡i cijelo stablo, a to Ä‡emo napraviti rekurzivno koristeÄ‡i pristup <strong>inorder</strong>.</p>
<p><code>BinarnoStablo.cs</code></p>
<pre><code language="language-cs" class="language-cs">public void Inorder(Cvor k)
{
    if (k != null)
    {
        Inorder(k.lijevo);
        Console.WriteLine(k.broj);
        Inorder(k.desno);
    }
}
</code></pre>
<p>Svaka rekurzija ima: osnovni sluÄaj i korak. U gornjem primjeru, za osnovni sluÄaj (kad je k jednak <strong>null</strong>) ne treba raditi niÅ¡ta veÄ‡ se rekurzija samo zavrÅ¡ava. U koraku rekurzije, mora se pozvati ponovo ista metoda, ali tako da se poÄetni problem pribliÅ¾i osnovnom sluÄaju (u gornjem primjeru - nakon cijelog stabla pozivamo rekurziju na lijevom i desnom podstablu). Prema tome, smanjujemo stablo sve dok ne doÄ‘emo na null.</p>
<p>Primjena u glavnom programu:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using bibStablo;

namespace primjer;

class Program
{
    static void Main(string[] args)
    {
        int[] niz = {50, 70, 25, 30, 15, 25, 81};
        BinarnoStablo bs = new BinarnoStablo();
        foreach (int br in niz)
        {
            bs.Dodaj(br);
        }

        bs.Inorder(bs.korijen);
    }
}
</code></pre>
<p>Program Ä‡e ispisati redom sve brojeve. Testni podaci sadrÅ¾e i duplu vrijednost (25). TakoÄ‘er, malo smeta Å¡to se u glavnom programu poziva metoda <strong>Inorder()</strong> kojoj moramo dati korijen kao parametar, a on veÄ‡ je dio klase. To je zato Å¡to smo izravno pozvali rekurzivnu metodu u glavnom programu.</p>
<p>Razmislite kako bi to promijenili tako da se pozove samo bs.Inorder() bez parametara!</p>
<h3 is-upgraded>ğŸ  <strong>Zadatak za domaÄ‡i rad</strong></h3>
<p>RijeÅ¡ite problem dodavanja u binarno stablo tako da metoda <strong>Dodaj()</strong> vraÄ‡a <strong>bool</strong>:</p>
<ul>
<li>True - ako je uspjeÅ¡no dodano</li>
<li>False - ako je bio dupli broj</li>
</ul>
<p>Kod unosa, ispisati u glavnom programu brojeve koji su bili duplikati:</p>
<pre><code>Duplikat: 25
15
25
30
50
70
81
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Dodavanje elemenata - rekurzivno" duration="0">
        <p>Za ispis smo koristili rekurziju, ali moÅ¾emo i za dodavanje. Osnovna ideja je prolaziti na sliÄan naÄin po stablu (lijevo ili desno) i traÅ¾iti praznu poziciju. Problem Ä‡emo razdvojiti na dva sluÄaja:</p>
<ul>
<li>Ako je stablo prazno - ne mora iÄ‡i u rekurziju,</li>
<li>Ako nije prazno pozivamo rekurzivnu metodu.</li>
</ul>
<p><code>BinarnoStablo.cs</code></p>
<pre><code language="language-cs" class="language-cs">public void Dodaj2(int br)
{
    Cvor novi = new Cvor(br);
    if (korijen == null)
        korijen = novi;
    else
        DodajRek(korijen, novi);
}
</code></pre>
<p>Rekurzija mora imati informacije na kojem dijelu stabla se nalazi i Å¡to dodajemo pa u ovom primjeru ima dva parametra.</p>
<ul>
<li>Ako je novi broj <strong>manji</strong>, onda Ä‡e provjeriti je li <strong>lijevo</strong> prazno te ga smjestiti, a u protivnom mora dalje na lijevo podstablo.</li>
<li>Ako je novi broj <strong>veÄ‡i</strong>, onda Ä‡e provjeriti je li <strong>desno</strong> prazno te ga smjestiti, a u protivnom mora dalje na desno podstablo.</li>
<li>Ako su jednaki, ne radi niÅ¡ta</li>
</ul>
<p><code>BinarnoStablo.cs</code></p>
<pre><code language="language-cs" class="language-cs">private void DodajRek(Cvor k, Cvor novi)
{
    if (novi.broj &lt; k.broj)
    {
        if (k.lijevo == null)
            k.lijevo = novi;
        else
            DodajRek(k.lijevo, novi);
    }
    else if (novi.broj &gt; k.broj)
    {
        if (k.desno == null)
            k.desno = novi;
        else
            DodajRek(k.desno, novi);
    }
    else
    {
        // niÅ¡ta
    }
}
</code></pre>
<aside class="warning"><p>â€‹â€‹ğŸ“Œ Opet je jako vaÅ¾no paziti na sve grane programa kako ne bi zaboravili neku moguÄ‡nost.</p>
</aside>
<p>Ako gore ne napiÅ¡emo niÅ¡ta za sluÄaj kad su jednaki, rekurzija Ä‡e zavrÅ¡iti.</p>
<p>ğŸ¯ <strong>Sad opet pokuÅ¡ajte rijeÅ¡iti zadatak s prethodne stranice, ali primjenom rekurzije!</strong></p>
<h3 is-upgraded>ğŸ  Zadatak za domaÄ‡i rad</h3>
<p>RijeÅ¡ite problem dodavanja u binarno stablo tako da metoda <strong>Dodaj()</strong> vraÄ‡a <strong>string</strong>:</p>
<ul>
<li>Poruka gdje je spremljen broj (npr. 50-korijen, 70 desno, 25 lijevo, 25 duplikat!, ...)</li>
<li>Poruka ako nije spremljen (npr. 25 duplikat)</li>
</ul>
<p>Napomena: ne mora biti rekurzija.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: UÄitaj brojeve" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Napisati konzolsku aplikaciju koja Ä‡e uÄitati podatke iz datoteke <strong><em>brojevi1.txt</em></strong> i smjestiti ih u binarno stablo.</p>
<ul>
<li>Ispisati sadrÅ¾aj stabla od najmanje do najveÄ‡e vrijednosti.</li>
<li>Ispisati sadrÅ¾aj stabla na ostala 2 naÄina.</li>
</ul>
<p class="image-container"><img alt="slika1.jpg" style="width: 357.33px" src="img/d1def839e74c6741.jpeg"></p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: TraÅ¾i po broju" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Nastavite rjeÅ¡avati u istom rjeÅ¡enju od prethodnog zadatka gdje je rijeÅ¡en unos podataka.</p>
<ul>
<li>Napisati metodu <strong>Trazi()</strong> koja prima <strong>cijeli broj</strong> kojeg treba pronaÄ‡i.</li>
<li>Metoda <strong>vraÄ‡a Ävor</strong> koji sadrÅ¾i traÅ¾enu vrijednost ili <strong>null</strong> ako ga nema.</li>
<li>U glavnom programu korisnik unosi traÅ¾eni broj, a program ispisuje je li pronaÄ‘en.</li>
</ul>
<h3 is-upgraded><strong>ğŸ¯ Za one koji Å¾ele viÅ¡e</strong></h3>
<p>a) NapiÅ¡ite metodu <strong>TraziPut()</strong> koja za razliku od prethodnog zadatka, vraÄ‡a <strong>string</strong> koji sadrÅ¾i put do traÅ¾enog Ävora i sam Ävor ili &#34;nema&#34; ako ga nema.</p>
<p>Primjer: za 489, ispisuje: &#34;500, 253, 494, 489&#34;, za 11 â†’ &#34;nema&#34;</p>
<p>b) NapiÅ¡ite metodu <strong>Udaljenost()</strong> koja vraÄ‡a broj Ävorova koje treba posjetiti do traÅ¾enog Ävora (brojati i sam Ävor) ili 0 ako ga nema. Primjer: za 500 â†’ put: 1, za 489 â†’ put: 4, za 11 â†’ 0.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: SluÄajni brojevi" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Napisati program (konzolsku aplikaciju) koji Ä‡e uÄitati u stablo sluÄajno odabrane brojeve iz intervala [10, 50].</p>
<ul>
<li>Korisnik upisuje koliko Å¾eli brojeva n,</li>
<li>Paziti na ispravnost broja n! Koliki smije biti?</li>
</ul>
<p>Ispisati brojeve iz stabla od najveÄ‡eg do najmanjeg:</p>
<ul>
<li>koristiti rekurziju za ispis</li>
<li>neka se metoda zove IspisMaxMin</li>
<li>za svaki dupli broj (npr. 11), ispisati poruku oblika: <strong>dupli broj: 11</strong></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
