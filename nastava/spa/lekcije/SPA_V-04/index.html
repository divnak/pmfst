
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>SPA: Uvod</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<link rel="stylesheet" href="css/prism-coy-all.css">
<script src="css/prism-coy-all.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="SPA_V-04"
                  title="SPA: Uvod"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Uvod" duration="0">
        <p>ğŸ“Œ Primjena gotovih klasa Stack/Queue</p>
<p>ğŸ“Œ Vezane liste - unos</p>
<p>ğŸ“Œ Vezane liste - brisanje</p>


      </google-codelab-step>
    
      <google-codelab-step label="UgraÄ‘ene klase Stack i Queue" duration="0">
        <h2 is-upgraded><strong>Queue</strong></h2>
<p><strong>Red</strong> (eng. Queue) je struktura podataka koja radi na principu &#34;prvi doÅ¡ao, prvi izaÅ¡ao&#34; (FIFO - First In, First Out). Ovaj koncept je nalik redu u stvarnom svijetu, gdje se prvi klijent uvijek prvi posluÅ¾uje. Red omoguÄ‡uje dodavanje elemenata na kraj strukture, dok se uklanjanje uvijek odvija na poÄetku. Na taj naÄin, red osigurava da se podaci obraÄ‘uju u istom redoslijedu u kojem su primljeni.</p>
<p>U C#-u, red se moÅ¾e implementirati koriÅ¡tenjem klase Queue, koja se nalazi u imenskom prostoru <strong>System.Collections</strong>. KoriÅ¡tenjem Queue klase, moguÄ‡e je lako implementirati osnovne operacije, ukljuÄujuÄ‡i dodavanje elemenata (metoda <strong>Enqueue</strong>) i uklanjanje elemenata (metoda Dequeue). TakoÄ‘er, metoda <strong>Peek</strong> omoguÄ‡uje pregled prvog elementa bez njegovog uklanjanja, Å¡to je korisno kada Å¾elimo provjeriti sljedeÄ‡i element bez izmjena u strukturi.</p>
<p>KoriÅ¡tenje klase <strong>Queue&lt;T&gt;</strong> koja se nalazi u <strong>System.Collections.Generic</strong> omoguÄ‡uje primjenu konkretnog tipa.</p>
<p class="image-container"><img alt="4815160669b03d57.png" style="width: 558.00px" src="img/4815160669b03d57.png"></p>
<p>Ako koristimo klasu Queue, onda moramo voditi raÄuna o pretvorbi tipova svaki put kad neÅ¡to moramo napraviti s tim podacima. Pogledajmo unos podataka:</p>
<pre><code>Queue q1 = new Queue();

// primjer unosa konstantnih vrijednosti
q1.Enqueue(&#34;tekst&#34;);
q1.Enqueue(122);
q1.Enqueue(3);
</code></pre>
<p>Implementacija gotove klase <strong>Queue</strong> dozvoljava &#34;Å¡etanje&#34; po redu primjerice pomoÄ‡u <strong>foreach</strong> petlje Äak po svim elementima bez izbacivanja. Ako Å¾elimo koristiti klasiÄno ponaÅ¡anje reda, odnosno izbacivanje prvog elementa, onda Ä‡e trebati postaviti varijablu na prvi element.</p>
<aside class="warning"><p>ğŸ“<strong>VaÅ¾no:</strong> Izbacujemo dok ima elemenata, a to nam vraÄ‡a <strong>svojstvo Count</strong>.</p>
</aside>
<pre><code>object t = q1.Peek();
while (q1.Count &gt; 0)
{
    Console.WriteLine(q1.Dequeue());
}
</code></pre>
<p>U gornjem primjeru koristimo varijablu tipa <strong>object</strong> u koju moÅ¾emo spremiti bilo Å¡to. MeÄ‘utim, problem je Å¡to ne znamo Å¡to smo spremili. Kod ispisa, metoda <strong>WriteLine()</strong> implicitno pretvara Å¡to god se nalazi u redu u string. Ako bi u redu unosili brojeve s kojima Å¾elimo neÅ¡to raÄunati ili spremamo sloÅ¾eni tip (primjerak klase ili struct-a), onda implicitna pretvorba nije moguÄ‡a.</p>
<p>U sljedeÄ‡em primjeru moÅ¾emo vidjeti postupak unosa brojeva u red.</p>
<ul>
<li>Korisnik unosi brojeve sve dok ne unese neÅ¡to Å¡to se ne moÅ¾e parsirati.</li>
<li>Nakon zavrÅ¡etka unosa, program izbacuje sve elemente redom te za svakog od njih ispisuje sljedbenika.</li>
</ul>
<p>Na ovaj naÄin smo &#34;prisilili&#34; korisnika da unosi cijele brojeve, ali svejedno kod izbacivanja moramo raditi eksplicitnu pretvorbu da bi broj stvarno mogli koristiti kao broj.</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Collections;

namespace test;

class Program
{
    static void Main(string[] args)
    {
        Queue q1 = new Queue();

        // unosimo brojeve
        bool ok = true;
        do
        {
            Console.WriteLine(&#34;Unesi broj: &#34;);
            int br;
            ok = int.TryParse(Console.ReadLine(), out br);

            if (ok) q1.Enqueue(br);
        } while (ok);

        // izbacimo brojeve i ispiÅ¡imo kvadrate svakog
        object t = q1.Peek();
        while (q1.Count &gt; 0)
        {
            // cast operator za pretvorbu
            int br = (int)q1.Dequeue();
            Console.WriteLine($&#34;Sljedbenik: {br + 1}&#34;);
        }
    }
}
</code></pre>
<p>Ako promijenimo tip u generiÄki, onda neÄ‡emo morati raditi pretvorbu, a ostatak ostaje isti.</p>
<pre><code>//...
Queue&lt;int&gt; q1 = new Queue&lt;int&gt;();
//...
int br = q1.Dequeue();
//...
</code></pre>
<p>Red ima razliÄite primjene, kao Å¡to su upravljanje procesima u operacijskom sustavu, simulacije stvarnih redova ili Äak osnovni sustavi za komunikaciju i razmjenu poruka. UÄenje o redovima i njihovim operacijama pruÅ¾a vaÅ¾ne osnove za rad s podacima koji zahtijevaju obradu u specifiÄnom redoslijedu. Na primjer, redovi se mogu koristiti za rasporeÄ‘ivanje zadataka u programiranju gdje je vaÅ¾no da se zadaci izvrÅ¡avaju toÄno onim redoslijedom kojim su stigli.</p>
<h2 is-upgraded><strong>Stack</strong></h2>
<p>Sve Å¡to je gore navedeno za <strong>red</strong> zapravo vrijedi i za <strong>stog</strong>, a jedina je razlika u tome Å¡to <strong>Stack</strong> ima metode <strong>Push()</strong> za dodavanje te <strong>Pop()</strong> za uklanjanje iz stoga te Ä‡e se redoslijed ispisa promijeniti u skladu s definicijom stoga.</p>
<p>Prednost gotovih klasa je jednostavna implementacija svih metoda, ali nedostatak je krÅ¡enje principa (FIFO/LIFO) jer se <em>foreach</em> petljom ipak moÅ¾e pristupiti svim elementima.</p>
<p>GeneriÄki tipovi omoguÄ‡uju brÅ¾u obradu podataka jer kompajler unaprijed zna tip podataka koji Ä‡e biti koriÅ¡ten, Å¡to omoguÄ‡uje optimizaciju koda. Razumijevanje instanciranja i konfiguriranja reda prema specifiÄnim potrebama programa presudno je za uÄinkovit rad sa sloÅ¾enim strukturama podataka.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Radix sort" duration="0">
        <p>Radix sort je algoritam sortiranja koji grupira brojeve prema njihovim znamenkama poÄevÅ¡i od najmanje znaÄajne znamenke (jedinice) do najveÄ‡e. UÄinkovit je za sortiranje kljuÄeva koji su iste duljine.</p>
<p>MoÅ¾e se implementirati i bez usporeÄ‘ivanja veÄ‡ rasporeÄ‘ivanjem svih elemenata u &#34;spremnike&#34; (eng. buckets) ovisno o vrijednosti znamenke. Ponavljanjem tog rasporeÄ‘ivanja, Radix Sort na kraju ostvaruje konaÄan poredak. Ako ga implementiramo na ovaj naÄin, onda moramo voditi raÄuna kako Ä‡emo zauzeti dodatan prostor u radnoj memoriji za pomoÄ‡ne nizove.</p>
<p>Ako imamo niz podataka s razliÄitim brojem znamenki, onda bi trebalo pronaÄ‡i najveÄ‡eg jer o njemu (njegovom broju znamenki) ovisi broj koliko puta Ä‡e se proÄ‡i kroz sve elemente niza.</p>
<p>U sljedeÄ‡em primjeru najveÄ‡i broj je troznamenkast te Ä‡e biti tri prolaza kroz algoritam. Za sve brojeve koji imaju manje znamenki, smatra se da su na poÄetku nule.</p>
<p class="image-container"><img alt="5d1fe42401314093.png" style="width: 326.67px" src="img/5d1fe42401314093.png"></p>
<p>Za naÅ¡u implementaciju, koristit Ä‡emo takoÄ‘er ideju spremnika (eng. buckets) bez operacije usporeÄ‘ivanja koji je veÄ‡i. Svaki spremnk Ä‡emo oznaÄiti znamenkom od 0 do 9 te Ä‡emo samo razmjestiti brojeve ovisno o tome koju znamenku promatramo.</p>
<p>Radi jednostavnosti, uzet Ä‡emo samo dvoznamenkaste brojeve kako bi na njima ilustrirali da algoritam radi. Naravno, vodite raÄuna kako ovaj naÄin implementacije nije nuÅ¾no uÄinkovit jer u ovom zadatku imamo drugaÄije ciljeve:</p>
<aside class="special"><p>âœ… Razumijevanje algoritma sortiranja <strong>Radix sort</strong>.</p>
<p>âœ… Primjena strukture <strong>red</strong> (klasa <strong>Queue&lt;int&gt;</strong>).</p>
</aside>
<p>Par ideja:</p>
<ul>
<li>Ovdje Ä‡e spremnike (ili kutije) glumiti <strong>redovi</strong> zato Å¡to Ä‡e brojevi ulaziti i izlaziti iz kutija po principu FIFO.</li>
<li>Koristit Ä‡emo tip <strong>Queue</strong> samo zato Å¡to je malo kompliciraniji kako bi uoÄili trenutak kad je potrebno napraviti pretvorbu.</li>
<li>Obzirom da imamo 10 znamenki, definirat Ä‡emo i 10 kutija s odgovarajuÄ‡im oznakama.</li>
<li>Broj kutija je fiksan i unaprijed poznat pa Ä‡emo koristiti <strong>niz</strong>.</li>
<li>OgraniÄenje primjera na dvoznamenkaste brojeve znaÄi da Ä‡emo imati samo dva prolaza: po jedinicama pa po deseticama.</li>
</ul>
<p>Pogledajmo na slici:</p>
<p class="image-container"><img alt="8b3a34890e2c096f.png" style="width: 624.00px" src="img/8b3a34890e2c096f.png"></p>
<p>KreÄ‡emo od crveno obojanog niza, ubacimo ga u kutije po <strong>jedinicama</strong> te vratimo elemente natrag u niz (plavi) i ubacimo ih ponovo prema <strong>deseticama</strong>. Na kraju Ä‡emo dobiti niz koji je sortiran (zeleni).</p>
<h2 is-upgraded><strong>Korak 1: Napraviti niz od 10 redova</strong></h2>
<pre><code>Queue[] redZnam = new Queue[10];
</code></pre>
<p>Obzirom da Ä‡e konstruktor svaki od 10 redova u poÄetku postaviti na <strong>null</strong> (to je zadana vrijednost), onda svaki moramo posebno instancirati (stvoriti objekt):</p>
<pre><code>for (int i = 0; i &lt; 10; i++)
    redZnam[i] = new Queue();
</code></pre>
<h2 is-upgraded><strong>Korak 2: Generirati n sluÄajno odabranih dvoznamenkastih brojeva</strong></h2>
<p>Sortiramo sluÄajno odabrane dvoznamenkaste brojeve pa je potrebno generirati i taj niz. Neka korisnik unese broj koliko brojeva Å¾eli sortirati.</p>
<pre><code>Console.Write(&#34;Unesi broj elemenata: &#34;);
int x = int.Parse(Console.ReadLine());
Random r = new Random();
int[] brojevi = new int[x];
for (int i = 0; i &lt; x; i++)
    brojevi[i] = r.Next(10, 100);
</code></pre>
<h2 is-upgraded><strong>Korak 3: Rasporediti brojeve po znamenkama</strong></h2>
<p>Ovaj korak se ponavlja dva puta, ali se postupak razlikuje minimalno pa moÅ¾emo napraviti metodu koja Ä‡e to obaviti. NapiÅ¡imo metodu <strong>RSort</strong> koja prima &#34;kutije&#34;, niz i koja znamenka je u pitanju.</p>
<pre><code>static void RSort(Queue[] q, int[] niz, int vrstaZ)
{}
</code></pre>
<p>Metoda Ä‡e proÄ‡i kroz sve elemente niza i uzimati znamenku ovisno o vrsti. Svaka znamenka odgovara indeksu kutije tako da je jednostavno ubaciti element u red koji pripada toj znamenki.</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">static void RSort(Queue[] q, int[] niz, int vrstaZ)
{
    int n = niz.Length;
    for (int i = 0; i &lt; n; i++)
    {
        int z;
        if (vrstaZ == 1) //ako su jedinice
            z = niz[i] % 10;
        else //ako su desetice
            z = niz[i] / 10;
        q[z].Enqueue(niz[i]); //stavi u odgovarajuÄ‡i red
    }
    //vrati natrag u niz
}
</code></pre>
<p>Dio s vraÄ‡anjem natrag u niz moÅ¾emo, a ne morao odvojiti u posebnu metodu. Ipak Ä‡emo odvojiti radi preglednosti kÃ´da.</p>
<p>Osnovna ideja je:</p>
<ul>
<li>ProÄ‡i kroz svih 10 &#34;kutija&#34; pa izbacivati elemente iz svake redom kako smo ih ubacili.</li>
</ul>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">static void Vrati_uNiz(Queue[] q, int[] niz)
{
    int j = 0;
    for (int i = 0; i &lt; 10; i++)
        while (q[i].Count &gt; 0)
        {
            niz[j] = (int)q[i].Dequeue();
            j++;
        }
}
</code></pre>
<p>Gornja metoda se moÅ¾e rijeÅ¡iti i bez <strong>cast</strong> operatora (ako ste navikli na <em>parsiranje</em>):</p>
<pre><code>niz[j] = int.Parse(q[i].Dequeue().ToString());
</code></pre>
<p>MeÄ‘utim taj postupak nije optimalan jer:</p>
<ul>
<li>Element reda je tipa <strong>object</strong> koji se ne moÅ¾e parsirati (parsiraju se <strong>samo stringovi</strong>).</li>
<li>Kako bi mogli parsirati, radimo pretvorbu u string pomoÄ‡u <strong>ToString()</strong> metode.</li>
<li>Nakon toga ide parsiranje.</li>
</ul>
<p>Ukupno imamo <strong>dvije</strong> pretvorbe za razliku od <strong>cast</strong> operatora koji izravno pretvara <strong>object</strong> u <strong>int</strong>.</p>
<p>Metodu za ispis takoÄ‘er moÅ¾emo napisati jer se ponavlja viÅ¡e puta.</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">static void IspisNiza(int[] niz)
{
    for (int i = 0; i &lt; niz.Length; i++)
        Console.Write(niz[i] + &#34; &#34;);
    Console.WriteLine();
}
</code></pre>
<p>Sad kad imate sve dijelove, napiÅ¡ite kompletno rjeÅ¡enje koje ima sljedeÄ‡i ispis:</p>
<p><code>Ispis:</code></p>
<pre><code>Unesi broj elemenata: 10

Prvi prolaz: 
40 90 61 44 54 54 26 77 27 38 

Drugi prolaz(konacno): 
26 27 38 40 44 54 54 61 77 90
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Vezane liste" duration="0">
        <p>Vezana lista je apstraktna struktura podataka koja povezuje elemente kroz veze (<strong>reference</strong>), sliÄno kao Å¡to su vagoni povezani u vlak.</p>
<p class="image-container"><img alt="8c60cfe8cea8de58.png" style="width: 386.67px" src="img/8c60cfe8cea8de58.png"></p>
<p>Svaki element u vezanoj listi naziva se Ävor, a svaki Ävor ima vezu s drugim Ävorovima, Å¡to omoguÄ‡ava lako dodavanje ili uklanjanje elemenata bez potrebe za pomicanjem podataka.</p>
<p>Postoje tri osnovne vrste vezanih lista:</p>
<ul>
<li>Jednostruke</li>
<li>Dvostruke</li>
<li>Cirkularne</li>
</ul>
<p>U jednostrukoj vezanoj listi svaki Ävor ima pokazivaÄ na sljedeÄ‡i Ävor, dok dvostruka lista omoguÄ‡uje pristup u oba smjera, jer svaki Ävor ima dodatni pokazivaÄ na prethodni Ävor. Kod cirkularnih lista, zadnji Ävor je povezan s prvim. Ove karakteristike Äine vezane liste izuzetno fleksibilnima za manipulaciju podacima.</p>
<p>Razumijevanje vezanih lista vaÅ¾no je jer omoguÄ‡uje stvaranje uÄinkovitijih struktura za pohranu podataka u sluÄajevima kada je potrebno Äesto mijenjati veliÄinu ili strukturu nekog popisa.</p>
<h2 is-upgraded><strong>PokazivaÄ na listu</strong></h2>
<p><em>PokazivaÄ</em> na listu, odnosno na prvi element liste Äesto se naziva <strong>head</strong>, ali u strukturi koja je implementirana u C# biblioteci naziva se <strong>First</strong>.</p>
<ul>
<li>Pokazuje na prvi element</li>
<li>Mora biti inicijaliziran (pokazuje na Ävor ili je null)</li>
</ul>
<p><strong>Head</strong> osigurava sekvencijalni pristup svakom Ävoru u listi tako da svaki Ävor poznaje samo svog sljedeÄ‡eg susjeda. Ako je postavljen na null, lista je prazna, Å¡to je korisno za provjeru postojanja elemenata prije izvrÅ¡avanja operacija poput pretraÅ¾ivanja ili brisanja.</p>
<p>TakoÄ‘er, <strong>head</strong> sluÅ¾i kao ulazna toÄka za sve operacije nad listom. Razumijevanje uloge pokazivaÄa pomaÅ¾e shavaÄ‡anju kako se odvija organizacija podataka unutar liste i kako se uÄinkovito upravlja elementima pomoÄ‡u jednostavnih veza.</p>
<h2 is-upgraded>ÄŒvorovi</h2>
<p><strong>ÄŒvor</strong> (eng. node) u vezanoj listi sastoji se od:</p>
<ul>
<li>podatkovnog polja i</li>
<li>pokazivaÄkog polja (reference)</li>
</ul>
<p>Podatkovno polje sadrÅ¾i vrijednost ili podatak koji Ävor predstavlja, dok pokazivaÄko polje sadrÅ¾i referencu prema sljedeÄ‡em Ävoru. U jednostrukim listama ovo pokazivaÄko polje se Äesto naziva <strong>Next</strong>, dok dvostruke liste imaju dodatno polje <strong>previous</strong> za vezu prema prethodnom Ävoru.</p>
<p>PokazivaÄko polje <strong>next</strong> omoguÄ‡ava prijelaz kroz listu Ävor po Ävor, dok u dvostrukim listama polje <strong>previous</strong> olakÅ¡ava kretanje u oba smjera. Ova struktura omoguÄ‡uje fleksibilno i uÄinkovito dodavanje i uklanjanje Ävorova unutar liste, posebno u situacijama gdje je vaÅ¾no zadrÅ¾ati toÄan redoslijed. Razumijevanje strukture Ävora kljuÄno je za rad s vezanim listama.</p>
<p>Ako radimo vlastitu strukturu vezane liste s posebnim Ävorovima, onda se ne moramo nuÅ¾no drÅ¾ati navedenih naziva niti strukture. MeÄ‘utim, ako koristimo gotovu klasu, onda je to upravo oblik Ävora.</p>
<p>Primjer klase <strong>Student</strong> koja ima oblik Ävora (jer sadrÅ¾i referencu <strong>next</strong>):</p>
<p><code>Student.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace UnosVL
{
    class Student
    {
        // ne moramo pisati svojstva
        public string ime;
        public int dob, mb;
        public Student next;

        public Student(string imeS, int dobS, int mbS)
        {
            this.ime = imeS;
            this.dob = dobS;
            this.mb = mbS;
            this.next = null;
        }

        public Student()
        {
            this.ime = &#34;&#34;;
            this.dob = 0;
            this.mb = 0;
            this.next = null;
        }

    }
}
</code></pre>
<h2 is-upgraded><strong>Temeljne operacije</strong></h2>
<ul>
<li><strong>Unos</strong> u listu - na poÄetak, kraj, iza ili prije nekog drugog elementa.</li>
<li><strong>Ispis</strong> elemenata liste - svih ili dijela.</li>
<li><strong>PretraÅ¾ivanje</strong> liste - traÅ¾enje elementa u listi po zadanom kriteriju.</li>
<li><strong>Brisanje</strong> jednog ili viÅ¡e elemenata iz liste.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Napraviti metode za rad s vezanom listom" duration="0">
        <p>Implementirajte sljedeÄ‡e metode:</p>
<ul>
<li>public void DodajNaPocetak(Student novi) â‡’ dodaje novi Ävor na poÄetak</li>
<li>public void DodajNaKraj(Student novi) â‡’ dodaje novi Ävor na kraj</li>
<li>public string Ispis() â‡’ vraÄ‡a string za ispis</li>
<li>public Student Trazi(int br) â‡’ vraÄ‡a Ävor koji je prvi pronaÄ‘en ili null, ako ga nema.</li>
</ul>
<p>Napomena: ova vezana lista se ne brine oko duplikata.</p>
<p>Neka klasa <strong>VezanaLista</strong> ima polje <strong>pocetak</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Za one koji Å¾ele neÅ¡to viÅ¡e" duration="0">
        <p>Implementirajte metode za brisanje elemenata vezane liste:</p>
<ul>
<li>Brisanje prvog</li>
<li>Brisanje zadnjeg</li>
<li>Brisanje po matiÄnom broju â‡’ Neka briÅ¡e prvog kojeg naÄ‘e.</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
