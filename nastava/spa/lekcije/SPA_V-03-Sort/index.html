
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>SPA-VjeÅ¾be 03: Sortiranje</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<link rel="stylesheet" href="css/prism-coy-all.css">
<script src="css/prism-coy-all.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="SPA_V-03-Sort"
                  title="SPA-VjeÅ¾be 03: Sortiranje"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Uvod" duration="90">
        <h2 is-upgraded><strong>Strukture podataka i algoritmi sortiranja u C#</strong></h2>
<p>U ovom dijelu Ä‡emo implementirati vlastitu strukturu podataka koristeÄ‡i niz te primijeniti osnovne algoritme sortiranja u obliku metoda koje Ä‡e biti dio te klase. Moramo se podsjetiti kako pristupamo Älanovima klase dok piÅ¡emo kod u tijelu klase i u nekom drugom dijelu programa.</p>
<h2 is-upgraded><strong>Temeljni pojmovi</strong></h2>
<ul>
<li>ğŸ“Œ <strong>Imenski prostori (eng. namespace)</strong> i koriÅ¡tenje <strong>using</strong> direktive.</li>
<li>ğŸ“Œ <strong>Klase</strong> u C# â€“ Definiranje i implementacija klase s poljima.</li>
<li>ğŸ“Œ <strong>Nizovi</strong> (eng. arrays) â€“ Pohrana podataka u niz.</li>
<li>ğŸ“Œ <strong>Metode</strong> za dodavanje, ispis, ureÄ‘ivanje.</li>
<li>ğŸ“Œ <strong>Algoritmi sortiranja</strong> (primjeri <em>bubble sort, selection sort, insertion sort</em>)</li>
<li>ğŸ“Œ <strong>Mjerenje vremena izvoÄ‘enja</strong> (DateTime, Stopwatch, TimeSpan)</li>
<li>ğŸ“Œ <strong>Rad s datotekama</strong> â€“ UÄitavanje i spremanje podataka iz/u tekstualnu datoteku.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Podsjetnik: Klase i imenski prostori u C#-u" duration="0">
        <h2 is-upgraded><strong>Imenski prostori</strong></h2>
<p>Imenske prostore (eng. namespace) koristimo kako bi organizirali kÃ´d te izbjegli potencijalne konflikte izmeÄ‘u naziva (ili imena) klasa, pogotovo u sloÅ¾enim projektima, gdje razliÄite klase ili metode mogu imati iste nazive. Npr. moÅ¾ete imati klasu s nazivom <strong>List</strong> u jednom imenskom prostoru, a potpuno drugaÄiju klasu <strong>List</strong> u drugom.</p>
<p>PomoÄ‡u imenskih prostora moÅ¾emo grupirati meÄ‘usobno povezane klase i metode u logiÄne cjeline (poveÄ‡avamo preglednost kÃ´da). Ako koristimo imenske prostore, odmah je jasno iz kojeg dijela dolazi odreÄ‘ena klasa ili metoda.</p>
<p>Na poÄetku svakog C# programa Ä‡ete najÄeÅ¡Ä‡e vidjeti liniju:</p>
<pre><code>using System;
</code></pre>
<p>Taj redak omoguÄ‡ava nam koriÅ¡tenje svih klasa unutar <strong>System</strong> imenskog prostora, poput <strong>Console</strong>, bez potrebe da svaki put piÅ¡emo <strong>System.Console</strong>. To je imenski prostor koji veÄ‡ postoji u bibliotekama kÃ´da. Ako piÅ¡emo vlastiti imenski prostor, onda navodimo sljedeÄ‡e:</p>
<pre><code>namespace StrukturaPodataka
{
    class MojPopis
    {
        // Tijelo klase
    }
}
</code></pre>
<p>Ako u nekom drugom projektu Å¾elimo koristiti veÄ‡ definiranu klasu iz imenskog prostora <em>StrukturaPodataka</em> onda jednostavno dodamo postojeÄ‡u <strong>cs</strong> datoteku u novi projekt te u novom projektu piÅ¡emo:</p>
<pre><code>StrukturaPodataka.MojPopis a = new StrukturaPodataka.MojPopis();
</code></pre>
<p>jer novi projekt nema isti naziv imenskog prostora.</p>
<p>Ako koristimo <strong>using StrukturaPodataka;</strong>, onda je dovoljno pisati:</p>
<pre><code>MojPopis a = new MojPopis();
</code></pre>
<aside class="warning"><p>â“ Å to bi se dogodilo ako bi samo promijenili naziv imenskog prostora <em>StrukturaPodataka</em> u naziv kojeg koristimo u projektu?</p>
</aside>
<p>Na prvi pogled se taj postupak Äini jednostavnim, ali u praksi nije. Naime, ako Ä‡emo koristiti tu novu strukturu u viÅ¡e projekata, onda svaki put moramo mijenjati &#34;originalnu&#34; <strong>cs</strong> datoteku. Kao Å¡to se inaÄe dogaÄ‘a s programskom podrÅ¡kom... Å¡to ako napravimo izmjene u toj strukturi? U tom sluÄaju, umjesto jednostavnog dodavanja nove <strong>cs</strong> datoteke, za svaki projekt moramo raditi usklaÄ‘ivanje naziva.</p>
<p>Imenski prostori su kljuÄni alat za upravljanje velikim i sloÅ¾enim projektima te osiguravaju urednu organizaciju i smanjenje moguÄ‡ih problema s nazivima.</p>
<h2 is-upgraded><strong>Klase</strong></h2>
<p>Klase imaju svoje Älanove (eng. members):</p>
<ul>
<li><strong>Polja</strong> (eng. fields)</li>
<li><strong>Svojstva</strong> (eng. properties)</li>
<li><strong>Metode</strong></li>
<li><strong>Konstruktore</strong></li>
</ul>
<p>Svi Älanovi klase mogu biti oznaÄeni modifikatorima pristupa:</p>
<ul>
<li><strong>private</strong> - dostupni samo unutar klase</li>
<li><strong>public</strong> - neograniÄen pristup (dostupno svima koji vide klasu)</li>
<li><strong>protected</strong> - ograniÄeno na klase koje nasljeÄ‘uju</li>
<li><strong>internal</strong> - sliÄno kao public, ali pristup je ograniÄen samo na trenutni skup biblioteka (<em>assembly</em>)</li>
</ul>
<p>Posebna vrsta modifikatora koja se moÅ¾e koristiti u kombinaciji s gore navedenima:</p>
<ul>
<li><strong>static</strong> - predstavljaju statiÄkog Älana koji <strong>pripada klasi, a ne objektu.</strong></li>
</ul>
<aside class="warning"><p>âš ï¸ Ako izostavimo modifikator pristupa, onda se podrazumijeva da je Älan klase <strong>private</strong>.</p>
</aside>
<p>Na ovom kolegiju neÄ‡emo koristiti <strong>protected</strong> jer je usko vezan uz koncept nasljeÄ‘ivanja koji se detaljnije obraÄ‘uje kasnije. Za ostalo je priliÄno jednostavno, ako nam treba neÅ¡to sakriti (zaÅ¡tititi), onda koristimo <strong>private</strong>, a ako Å¾elimo omoguÄ‡iti dostupnost (vidljivost) van klase onda koristimo <strong>public</strong>.</p>
<p>Ako nam treba &#34;finija&#34; kontrola nad nekim poljem, npr. treba nam podatak koji je samo za Äitanje (eng. read-only) kao Å¡to je to primjerice <strong>Length</strong> za niz, onda Ä‡emo tu namjenu koristiti <strong>svojstvo</strong>. Naime, svojstvo se sastoji od dva dijela:</p>
<ul>
<li>dohvaÄ‡anja/Äitanja spremljenog podatka (get) i</li>
<li>spremanja/postavljanja podataka (set)</li>
</ul>
<p>U svakom od ta dva navedena dijela moÅ¾emo pisati dodatni kÃ´d kojim kontroliramo pristup. Na primjer, ako korisnik pokuÅ¡a upisati prazan string za ime, moÅ¾e se javiti iznimka (greÅ¡ka) ili se moÅ¾e spremiti tekst &#34;nepoznato&#34; i sl.</p>
<p>Å to je s <strong>internal</strong>? Pojednostavljeno, jako je sliÄan <strong>public</strong> tako da ga neÄ‡emo koristiti. Za potrebe izrade projekata na ovom kolegiju, zapravo niti nema razlike. ÄŒlanovi oznaÄeni s internal su javno dostupni svima ostalima unutar jednog <strong><em>assembly</em></strong>.</p>
<p>Ovdje smo ostavili engleski naziv jer je malo teÅ¾e (ili nespretnije) prevesti taj pojam. Podrazumijeva fiziÄku jedinicu kÃ´da koja sadrÅ¾i sve Å¡to je potrebno kako bi se odreÄ‘eni dio programa izvrÅ¡io (klase, metode itd.) te informacije (metapodatke) koje su potrebne kako bi sve funkcioniralo (verzije, resursi, sigurnosne informacije i sl.). Dijeli se na izvrÅ¡ne <strong>exe</strong> datoteke i <strong>dll</strong> datoteke s bibliotekama kÃ´da. Kad napravite sloÅ¾enije projekte, onda se vaÅ¡a aplikacija moÅ¾e sastojati od viÅ¡e takvih <em>assembly-ja</em>.</p>
<p>Svaki <em>assembly</em> moÅ¾e sadrÅ¾avati viÅ¡e imenskih prostora. Primjerice, kad instalirate neki program (aplikaciju) na vaÅ¡e raÄunalo, taj program se sastoji od jedne viÅ¡e <strong>exe</strong> i <strong>dll</strong> datoteka koje su razliÄiti <em>assembly</em>-ji.</p>
<p>Kad <em>kompajlirate</em> vaÅ¡ projekt, takoÄ‘er se generiraju <strong>dll</strong> datoteke (1 ili viÅ¡e, ovisno o tome Å¡to koristite).</p>
<p class="image-container"><img alt="788fbcec78eaf015.png" style="width: 168.67px" src="img/788fbcec78eaf015.png"></p>
<p>Dakle, <em>assembly</em> moÅ¾emo zamisliti kao <em>paket</em> koji sadrÅ¾i sve potrebne dijelove za rad aplikacije.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Mjerenje vremena izvoÄ‘enja" duration="0">
        <p>Prije nego Å¡to krenemo s implementacijom, napravit Ä‡emo pregled naÄina na koje moÅ¾emo mjeriti vrijeme izvoÄ‘enja nekog programa. Mjerenje vremena izvoÄ‘enja programa je vaÅ¾no jer nam pomaÅ¾e razumjeti koliko je naÅ¡ kÃ´d uÄinkovit. U svijetu programiranja, uÄinkovitost je kljuÄna jer se ne radi samo o tome da program radi, nego i o tome koliko brzo i s koliko resursa se izvrÅ¡ava.</p>
<p>Neki algoritmi mogu rijeÅ¡iti isti problem na razliÄite naÄine, ali s vrlo razliÄitim brzinama. Mjerenjem vremena izvoÄ‘enja moÅ¾emo odabrati najbrÅ¾i algoritam ili pristup za odreÄ‘eni zadatak. Na primjer, BubbleSort je u odreÄ‘enim situacijama sporiji od drugih algoritama, pa je vaÅ¾no znati koliko je vremena potrebno razliÄitim algoritmima na razliÄitim skupovima i vrstama podataka. S poveÄ‡anjem koliÄine podataka, neki algoritmi postaju znaÄajno sporiji.</p>
<p>Ne smijemo zaboraviti i iskustvo korisnika. Ako program dugo izvrÅ¡ava neki zadatak, korisnici mogu postati frustrirani ili ga Äak prestati koristiti.</p>
<p>Kad spominjemo uÄinkovite programe koji se temelje na paÅ¾ljivo odabranim strukturama podataka i algoritmima, onda ne smijemo zaboraviti kako pored vremena izvoÄ‘enja &#34;troÅ¡e&#34; i radnu memoriju te samim tim i dodatne resurse. Prema tome, vaÅ¾no je znati Å¡to i kako implementirati kako bi smanjili troÅ¡kove.</p>
<p>Ovdje Ä‡emo se osvrnuti detaljnije samo na vrijeme jer nam je to jednostavno.</p>
<p>NaÄine mjerenja (za potrebe uÄenja i nastave) moÅ¾emo podijeliti na:</p>
<ul>
<li>Mjerenje s <strong>DateTime</strong> - jednostavno oduzimanje vremena poÄetka i kraja,</li>
<li>Primjena klase <strong>Stopwatch</strong> - preciznije mjerenje od prethodnog ,</li>
<li>Mjerenje vremena izvrÅ¡avanja procesa - primjena <strong>TimeSpan</strong> i <strong>Process</strong>.</li>
</ul>
<p><strong>TimeSpan</strong> predstavlja odreÄ‘eni vremenski period izraÅ¾en u obliku pozitivnih ili negativnih brojeva dana, sati, minuta, sekundi i dijelova sekunde. Vrijednost TimeSpan objekta predstavljena je kao:</p>
<ul>
<li>â€‹â€‹[-]d.hh:mm:ss.ff (predznak je opcionalan, <strong>d</strong> oznaÄava broj dana, <strong>hh</strong> broj sati, <strong>mm</strong> broj minuta, <strong>ss</strong> broj sekundi, a <strong>ff</strong> dijelove sekunde),</li>
<li>broj otkucaja (eng. ticks) u nekom vremenskom intervalu, a jedan â€tick&#34; za TimeSpan odgovara 100 nanosekundi.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Mjerenje izvoÄ‘enja s DateTime" duration="0">
        <p>Prije dijela kÃ´da za kojeg Å¾elimo izmjeriti vrijeme piÅ¡emo:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;

namespace test; // novi naÄin pisanja za namespace

class Program
{
    static void Main(string[] args)
    {
        // deklariramo varijablu
        DateTime pocetak;

        pocetak = DateTime.Now;
        // dio programa kojeg mjerimo
        Console.WriteLine(&#34;Hello, World!&#34;);
        // kraj mjerenja
        TimeSpan kraj = DateTime.Now.Subtract(pocetak);

        Console.WriteLine(&#34;Vrijeme: &#34; + kraj);
    }
}
</code></pre>
<p>Primijetite kako ne moramo posebno izdvajati sekunde, minute itd. veÄ‡ postoji metoda Subtract() kojom moÅ¾emo jednostavno obaviti raÄunanje. Ako zadrÅ¾imo strelicu miÅ¡a na metodi, VS Code Ä‡e nam dati neke informacije (isjeÄak na slici):</p>
<p class="image-container"><img alt="ae5a24ac8871cf2b.png" style="width: 386.67px" src="img/ae5a24ac8871cf2b.png"></p>
<p>Vidimo kako metoda <strong>Subtract() prima</strong> vrijednost tipa <strong>DateTime</strong>, a <strong>vraÄ‡a</strong> vrijednost tipa <strong>TimeSpan</strong>.</p>
<p>Nakon pokretanja programa, ispisat Ä‡e se poruka sliÄna ovoj:</p>
<pre><code>Hello, World!
Vrijeme: 00:00:00.0514960
</code></pre>
<p>Ako viÅ¡e puta pokrenete program, primijetit Ä‡ete i kako se vrijeme izvoÄ‘enja razlikuje iako nismo mijenjali program.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Primjena Stopwatch" duration="0">
        <p><strong>Stopwatch</strong> klasa u C#-u omoguÄ‡uje preciznije mjerenje vremena koje je proteklo izmeÄ‘u dvije toÄke u vaÅ¡em programu. <strong>To je klasa iz System.Diagnostics</strong> imenskog prostora koja koristi unutarnji sat procesora za toÄno praÄ‡enje vremena, pa je korisna za mjerenje performansi algoritama i dijelova koda.</p>
<p>Za razliku od jednostavnog koriÅ¡tenja DateTime objekta, Stopwatch pruÅ¾a precizniji pristup jer je ta klasa oblikovana upravo za mjerenje vremena izvoÄ‘enja.</p>
<p>KoriÅ¡tenje Stopwatch klase je vrlo jednostavno, a slijedi ovaj osnovni pristup:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Diagnostics;

namespace test;

class Program
{
    static void Main(string[] args)
    {
        // Inicijalizacija Stopwatch instance
        Stopwatch sw = new Stopwatch();

        // Pokretanje mjerenja vremena
        sw.Start();

        // Kod Äije vrijeme izvoÄ‘enja Å¾elimo mjeriti
        for (int i = 0; i &lt; 1000000; i++)
        {
            // Simulacija operacije
        }

        // Zaustavljanje mjerenja vremena
        sw.Stop();

        // Ispis proteklog vremena
        Console.WriteLine(&#34;Vrijeme: &#34; + sw.Elapsed);
        Console.WriteLine(&#34;MS: &#34; + sw.ElapsedMilliseconds + &#34; ms&#34;);
        Console.WriteLine(&#34;Ticks: &#34; + sw.ElapsedTicks + &#34; ticks&#34;);
    }
}
</code></pre>
<p>Izlaz</p>
<pre><code>Vrijeme: 00:00:00.0025961
MS: 2 ms
Ticks: 2664403 ticks
</code></pre>
<p>Broj otkucaja (ticks) ovisi o raÄunalu i operacijskom sustavu tako da neÄ‡e biti isti na razliÄitim raÄunalima.</p>
<p>Kao Å¡to moÅ¾ete primijetiti u VS Code-u, objekt <strong>sw</strong> iz gornjeg primjera ima <strong>svojstva</strong>:</p>
<p class="image-container"><img alt="977bda4de92ec683.png" style="width: 301.00px" src="img/977bda4de92ec683.png"></p>
<p>Prepoznajemo ih po specifiÄnoj &#34;ikonici&#34;.</p>
<p>Klasa <strong>Stopwatch</strong> ima metode:</p>
<ul>
<li><strong>Start</strong>() - pokreÄ‡e brojaÄ,</li>
<li><strong>Stop</strong>() - zaustavlja brojaÄ,</li>
<li>Reset() - postavlja brojaÄ na 0,</li>
<li>Restart() - kombinira Reset() i Start() - postavlja brojaÄ na 0 i ponovo pokreÄ‡e mjerenje (ako je veÄ‡ bilo pokrenuto, zaustavit Ä‡e ga prije postavljanja na 0).</li>
</ul>
<h2 is-upgraded><strong>Problem smeÄ‡a u memoriji</strong></h2>
<p>Kada mjerimo vrijeme izvoÄ‘enja programa, vaÅ¾no je razumjeti kako C# upravlja memorijom jer to moÅ¾e znaÄajno utjecati na performanse. U C#-u, memorija se koristi na dva glavna naÄina: kroz <strong>stog</strong> (stack) i <strong>gomilu</strong> (heap). Ovi pojmovi su kljuÄni za razumijevanje kako se program ponaÅ¡a u pogledu resursa te zaÅ¡to je vaÅ¾no mjeriti i optimizirati vrijeme izvoÄ‘enja.</p>
<p>C# dijeli podatke na dvije glavne vrste:</p>
<ul>
<li><strong>referentni</strong> tipovi - ukljuÄuju stringove, nizove, instance klasa, itd.</li>
<li><strong>vrijednosni</strong> tipovi - ukljuÄuju jednostavne numeriÄke tipove, stringove, bool i sl.</li>
</ul>
<p>Kada koristimo referentni tip, konkretni podaci (ili objekt) se pohranjuju na gomilu (heap), dok se referenca na te podatke Äuva na stogu (stack). S druge strane, sadrÅ¾aj vrijednosnih tipova se izravno sprema na stogu jer sadrÅ¾e stvarnu vrijednost, a ne samo referencu.</p>
<p>Kad metoda zavrÅ¡i, sve varijable koje su se tu nalazile se automatski briÅ¡u iz radne memorije koja se prema tome oslobaÄ‘a. Za razliku od stoga, dio memorije organizirane u obliku <em>gomile</em> neÄ‡e se automatski poÄistiti veÄ‡ se koristi poseban mehanizam <strong>skupljanja smeÄ‡a</strong> (eng. garbage collection, GC). C# koristi automatsko upravljanje memorijom. To znaÄi da programer ne mora ruÄno oslobaÄ‘ati memoriju kao Å¡to je to sluÄaj u nekim drugim programskim jezicima (npr. C ili C++), ali to ne znaÄi da je upravljanje memorijom potpuno zanemarivo.</p>
<p>Skupljanje smeÄ‡a je proces koji traÅ¾i objekte u radnoj memoriji koji viÅ¡e nisu dostupni, odnosno u programu viÅ¡e ne postoje reference na te objekte. Taj proces moÅ¾e povremeno uzrokovati kratke pauze u vaÅ¡em programu.</p>
<p><em>Garbage collector</em> se obiÄno pokreÄ‡e kada memorija postane ograniÄena ili kada postoji mnogo nepotrebnih objekata u memoriji. Ipak, GC nije predvidiv, Å¡to znaÄi da se moÅ¾e dogoditi u bilo kojem trenutku.</p>
<p>MoÅ¾emo programerski pokrenuti izvrÅ¡avanje: <strong>GC.Collect();</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Mjerenje vremena izvrÅ¡avanja procesa" duration="0">
        <p><strong>Stopwatch</strong> mjeri ukupno vrijeme koje je proteklo od trenutka kada je pokrenut brojaÄ do trenutka kada je zaustavljen. To ukljuÄuje i vrijeme kada CPU nije bio zauzet izvrÅ¡avanjem vaÅ¡eg koda, npr. zbog pauza koje su nastale izvrÅ¡avanjem nekih drugih procesa.</p>
<p><strong>Process.GetCurrentProcess().UserProcessorTime</strong> mjeri procesorsko vrijeme (CPU) koje je konkretan proces aktivno troÅ¡io. Ovo ne ukljuÄuje vrijeme dok je proces Äekao na neÅ¡to (npr. dohvaÄ‡anje podataka s diska i sl.) ili dok je sustav izvrÅ¡avao druge procese.</p>
<p>Dakle, ovaj naÄin mjerenja moÅ¾emo koristiti kada Å¾elimo vidjeti koliko procesorskog vremena program aktivno koristi, a ne koliko je stvarnog vremena proteklo.</p>
<p>Pogledajte primjer kako je implementirana klasa koja mjeri vrijeme izvrÅ¡avanja procesa:</p>
<p><code>Mjerenje.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Diagnostics;

namespace Biblioteka
{
    class Mjerenje
    {
        private TimeSpan pocetak, ukupno;
        // konstruktor
        public Mjerenje()
        {
            pocetak = new TimeSpan(0);
            ukupno = new TimeSpan(0);
        }
        // sprema vrijeme kad je proces poÄeo raditi
        // prije poÄetka Ä‡e pokupiti i smeÄ‡e
        public void Start()
        {
            GC.Collect();
            GC.WaitForPendingFinalizers();
            pocetak = Process.GetCurrentProcess()
                      .UserProcessorTime;
        }
        // sprema razliku vremena
        public void Stop()
        {
            ukupno = Process.GetCurrentProcess()
                     .UserProcessorTime.Subtract(pocetak);
        }
        // koristimo metodu jer ukupno nije public
        public TimeSpan Trajanje()
        {
            return ukupno;
        }

    }
}
</code></pre>
<p>Primijenimo novu klasu u glavnom programu:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Diagnostics;
// koristimo ovo jer nije isti namespace!
using Biblioteka;

namespace test;

class Program
{
    static void Main(string[] args)
    {
        Mjerenje m = new Mjerenje();
        m.Start();
        // Kod Äije vrijeme izvoÄ‘enja Å¾elimo mjeriti
        for (int i = 0; i &lt; 1000000; i++)
        {
            // Simulacija operacije
        }
        m.Stop();
        Console.WriteLine(&#34;Vrijeme: &#34; + m.Trajanje());
    }
}
</code></pre>
<p>Izlaz:</p>
<pre><code>Vrijeme: 00:00:00.0029470
</code></pre>
<aside class="special"><p><strong>Pregled:</strong></p>
<p>â›” RaÄunanje razlike vremena (DateTime) - primitivan naÄin.</p>
<p>âœ… Primjena <strong>Stopwatch</strong> - prihvatljivo.</p>
<p>âœ… Primjena raÄunanja vremena procesa - nije primjenjivo za ove vjeÅ¾be.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“—Zadatak: Implementacija klase" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>U ovom zadatku napravit Ä‡emo klasu koja koristi niz za pohranu cijelih brojeva. Implementirat Ä‡emo osnovne metode za rad s podacima i metode za sortiranje.</p>
<p>Klasa <strong>KlasaNiz</strong> ima polja i metode.</p>
<p>Polja:</p>
<ul>
<li>Niz cijelih brojeva: <strong>int[] niz</strong></li>
<li>Koliko je trenutno upisano elemenata: <strong>brojac</strong></li>
</ul>
<p>Prvo polje je <strong>public</strong> jer Ä‡e nam kasnije trebati pristup elementima.</p>
<aside class="warning"><p>â“ZaÅ¡to koristimo varijablu <strong>brojac</strong> kad imamo <strong>Length</strong>?</p>
</aside>
<p>Metode:</p>
<ul>
<li><strong>Dodaj</strong>() - prima cijeli broj i dodaje ga u niz</li>
<li><strong>PopisElemenata</strong>() - ne prima niÅ¡ta, ali vraÄ‡a popis elemenata u obliku stringa (brojevi odvojeni zarezom)</li>
<li><strong>BubbleSort</strong>() - ne prima niÅ¡ta, obavlja sortiranje</li>
<li><strong>SelectionSort</strong>() - ne prima niÅ¡ta, obavlja sortiranje</li>
<li><strong>InsertionSort</strong>() - ne prima niÅ¡ta, obavlja sortiranje</li>
</ul>
<p>Konstruktor:</p>
<ol type="1">
<li>Prima dimenziju (veliÄinu) niza, stvara novi niz i postavlja brojaÄ na 0.</li>
</ol>
<h2 is-upgraded><strong>Korak 1: preuzimanje predloÅ¡ka</strong></h2>
<p>Radi jednostavnosti, napravite sljedeÄ‡e:</p>
<ul>
<li>Novi konzolski projekt pod nazivom <strong>Zad01</strong>.</li>
<li>Dodajte <strong>cs</strong> datoteku <strong>KlasaNiz.cs</strong>.</li>
<li>Kopirajte sadrÅ¾aj za KlasaNiz.cs i Program.cs.</li>
</ul>
<p><code>KlasaNiz.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace Biblioteka
{
    class KlasaNiz
    {
        public int[] niz;
        private int brojac; // koliko je upisano
        public KlasaNiz(int velicina)
        {
            niz = new int[velicina];
            brojac = 0;
        }
        
        public void Dodaj(int broj)
        {
            niz[brojac] = broj;
            brojac++;
        }
        public string PopisElemenata()
        {
            string ispis = &#34;&#34;;
            foreach (int el in niz)
            {
                ispis += el + &#34;,&#34;;
            }
            return ispis.Trim(&#39;,&#39;);
        }

        //sort
        public void BubbleSort()
        {
            
        } //bubble sort

        public void SelectionSort()
        {
            
        } //selection sort

        public void InsertionSort()
        {
            
        } //insert sort
    }
}
</code></pre>
<p>Glavni dio programa (za sad) izgleda ovako:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Diagnostics;
using Biblioteka;

namespace Zad01;

class Program
{
    static void Main(string[] args)
    {
        Console.Write(&#34;Koliko brojeva Å¾elite? &#34;);
        int n = int.Parse(Console.ReadLine());

        // napraviti novi objekt
        // dodati sluÄajne brojeve

    }
}
</code></pre>
<h2 is-upgraded><strong>Korak 2: Primjena nove strukture</strong></h2>
<p>Napunite naÅ¡u novu strukturu s n sluÄajno odabranih brojeva iz intervala [1, 100] i ispiÅ¡ite sadrÅ¾aj niza.</p>
<ol type="1">
<li>Napravit Ä‡emo novi objekt.</li>
<li>SluÄajne brojeve Ä‡emo generirati primjenom klase <strong>Random</strong> i metode <strong>Next()</strong>, a dodat Ä‡emo ih u novu strukturu pomoÄ‡u metode <strong>Dodaj()</strong>.</li>
<li>Brojeve Ä‡emo ispisati pozivom metode <strong>PopisElemenata()</strong> koja vraÄ‡a string.</li>
</ol>
<p>Ispis bi trebao izgledati ovako:</p>
<pre><code>Koliko brojeva Å¾elite? 10
3,26,5,55,18,60,15,42,44,59
</code></pre>
<aside class="warning"><p>â“ZaÅ¡to smo koristili metodu <strong>PopisElemenata()</strong> umjesto ispisa na konzolu u klasi <strong>KlasaNiz</strong>?</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“—Zadatak: Bubble sort" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Nastavit Ä‡emo raditi na prethodnom programu. Implementirajte bubble sort algoritam, sortirajte niz brojeva.</p>
<h3 is-upgraded><strong>Bubble sort</strong></h3>
<p>Bubble Sort je jednostavan algoritam za sortiranje koji usporeÄ‘uje susjedne elemente u nizu i zamjenjuje ih ako su u pogreÅ¡nom redoslijedu. Ovaj proces se ponavlja sve dok cijeli niz ne bude sortiran.</p>
<p>Neka je zadan niz brojeva:</p>
<p class="image-container"><img alt="b7f4882d9c659a97.png" style="width: 354.00px" src="img/b7f4882d9c659a97.png"></p>
<p>Kako Bubble Sort radi:</p>
<ol type="1">
<li>PoÄnemo od prvog elementa niza i usporeÄ‘ujemo ga sa sljedeÄ‡im.</li>
<li>Ako je prvi element veÄ‡i od drugog, zamijenimo ih.</li>
<li>Zatim prelazimo na sljedeÄ‡i par elemenata (drugi i treÄ‡i element) i ponavljamo usporedbu i zamjenu.</li>
</ol>
<p>Ovaj proces se nastavlja do kraja niza, Å¡to dovodi do toga da &#34;najveÄ‡i&#34; element ispliva na kraj niza â€“ baÅ¡ kao mjehur koji se podiÅ¾e na povrÅ¡inu (otuda naziv &#34;bubble sort&#34;).</p>
<p class="image-container"><img alt="5a231213e337bb13.png" style="width: 354.00px" src="img/5a231213e337bb13.png"></p>
<p>Obavimo zamjenu.</p>
<p class="image-container"><img alt="7a4a55badc32c44a.png" style="width: 354.00px" src="img/7a4a55badc32c44a.png"></p>
<p>Nema zamjene.</p>
<p class="image-container"><img alt="389375964532d67c.png" style="width: 354.00px" src="img/389375964532d67c.png"></p>
<p class="image-container"><img alt="c72195827d66dc0.png" style="width: 354.00px" src="img/c72195827d66dc0.png"></p>
<p class="image-container"><img alt="a05f273c53c65bb1.png" style="width: 354.00px" src="img/a05f273c53c65bb1.png"></p>
<p class="image-container"><img alt="9e099877de1950f4.png" style="width: 353.00px" src="img/9e099877de1950f4.png"></p>
<p>Nakon Å¡to smo proÅ¡li cijeli niz, ponovno ponavljamo postupak, ali ovaj put ignoriramo zadnji element (jer je on veÄ‡ na svom mjestu). Proces ponavljamo sve dok niz ne bude potpuno sortiran. Ako je niz veÄ‡ sortiran, onda neÄ‡e biti zamjena.</p>
<p class="image-container"><img alt="7a95999aaccf4afd.png" style="width: 353.00px" src="img/7a95999aaccf4afd.png"></p>
<p>Ovdje Ä‡emo malo ubrzati (neÄ‡emo pisati svaki korak). Nakon Å¡to proÄ‘u sve usporedbe, dobit Ä‡emo stanje u kojem Ä‡e najveÄ‡i od ostatka niza zavrÅ¡iti na kraju:</p>
<p class="image-container"><img alt="7497f8ddf3163697.png" style="width: 353.00px" src="img/7497f8ddf3163697.png"></p>
<p>Nakon sljedeÄ‡eg prolaza 15 dolazi do svoje pozicije:</p>
<p class="image-container"><img alt="ee54314d906c80ad.png" style="width: 323.00px" src="img/ee54314d906c80ad.png"></p>
<p>Nakon ovog prolaza, algoritam zavrÅ¡ava jer s preostala tri elementa viÅ¡e nema zamjena.</p>
<p>Sad to jednostavno moramo prebaciti u formalni jezik, C#. Metoda ne prima niÅ¡ta i ne vraÄ‡a niÅ¡ta:</p>
<pre><code>public void BubbleSort()
{
    
} //bubble sort
</code></pre>
<p>Na kraju metode moÅ¾emo staviti komentar kako bi nam se bilo lakÅ¡e snaÄ‡i u pisanju kÃ´da.</p>
<p>Metoda ne prima niÅ¡ta jer piÅ¡emo kÃ´d unutar klase gdje joj je dostupno lokalno polje (varijabla) <strong>niz</strong> u kojoj su podaci. TakoÄ‘er, metoda ne mora niÅ¡ta vraÄ‡ati jer izravno manipulira s podacima koji su u nizu.</p>
<p>Cijeli postupak ponavljamo dok ima ponavljanja - izgleda da nam je potrebna petlja s nepoznatim brojem ponavljanja, odnosno uvjetom, a to je <strong>while</strong> ili <strong>do-while</strong>. Svakako moramo obaviti bar jedan prolaz pa bi nam do-while odgovarala. MeÄ‘utim, kako inaÄe u nekim programskim jezicima nemamo takav tip petlje, pokuÅ¡at Ä‡emo rijeÅ¡iti s petljom while.</p>
<pre><code>public void BubbleSort()
{
    bool zamjena = true;
    while (zamjena)
    {
        zamjena = false;
        // ostalo
    }
} //bubble sort
</code></pre>
<p>Obzirom da se petlja izvodi dok ima zamjena, najprije Ä‡emo spremiti <strong>true</strong> kako bi ostvarili prvi ulazak u petlju, a na samom poÄetku tijela petlje Ä‡emo postaviti na <strong>false</strong>.</p>
<p>Nakon toga nam treba petlja koja Ä‡e usporeÄ‘ivati dva susjedna elementa poÄevÅ¡i od prvog (0). Ako ne budu u ispravnom poretku, zamijeniti ih te promijeniti vrijednost varijable <em>zamjena</em>.</p>
<aside class="warning"><p>ğŸ’¡Ne zaboravite, nakon Å¡to usporedimo sve parove do kraja, onda petlja viÅ¡e neÄ‡e iÄ‡i do zadnjeg elementa.</p>
</aside>
<p>Sada u glavni dio programa primjenjujemo novu metodu.</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Diagnostics;
using Biblioteka;

namespace Zad01;

class Program
{
    static void Main(string[] args)
    {
        Console.Write(&#34;Koliko brojeva Å¾elite? &#34;);
        int n = int.Parse(Console.ReadLine());

        // napraviti novi objekt
        KlasaNiz a = new KlasaNiz(n);
        // dodati sluÄajne brojeve
        Random g = new Random();
        for (int i = 0; i &lt; n; i++)
        {
            a.Dodaj(g.Next(1, 101));
        }

        // BubbleSort
        Console.WriteLine(a.PopisElemenata());
        a.BubbleSort();
        Console.WriteLine(&#34;BubbleSort\n&#34; + a.PopisElemenata());
    }
}
</code></pre>
<p>Ispis:</p>
<pre><code>Koliko brojeva Å¾elite? 10
57,88,1,15,45,31,44,82,3,93
BubbleSort
1,3,15,31,44,45,57,82,88,93
</code></pre>
<p>PokuÅ¡ajte sortirati 100 brojeva, Å¡to Ä‡e se dogoditi?</p>
<p>Obzirom da Å¾elimo mjeriti vrijeme izvoÄ‘enja algoritma na velikoj koliÄini brojeva, onda Ä‡e nam ispis smetati. Prema tome, dodajte uvjet u metodu za ispis tako da ne ispisuje niz ako ima viÅ¡e od 20 elemenata.</p>
<p><code>KlasaNiz.cs</code></p>
<pre><code language="language-cs" class="language-cs">public string PopisElemenata()
{
    if (this.niz.Length &gt; 20)
        return &#34;...&#34;;
    string ispis = &#34;&#34;;
    foreach (int el in niz)
    {
        ispis += el + &#34;,&#34;;
    }
    return ispis.Trim(&#39;,&#39;);
}
</code></pre>
<p>Ispis:</p>
<pre><code>Koliko brojeva Å¾elite? 50
...
BubbleSort
...
</code></pre>
<p>Sad ne vidimo ispis, ali moÅ¾emo mjeriti vrijeme.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“—Zadatak: neki drugi sort" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Mjerenje Äesto provodimo kako bi usporedili vrijeme izvoÄ‘enja razliÄitih algoritama. Implementirajte neki drugi algoritam te ga usporedite s bubble sort algoritmom. MoÅ¾ete odabrati jedan od:</p>
<ul>
<li>Insertion (ili insert) sort - sortiranje umetanjem</li>
<li>Selection (ili select) sort - sortiranje odabirom</li>
</ul>
<p>PronaÄ‘ite upute (algoritam) kako radi Å¾eljeni algoritam, implementirajte ga i testirajte na razliÄitim vrstama podataka.</p>
<p>Koristite <strong>Stopwatch</strong> za mjerenje vremena izvoÄ‘enja.</p>
<pre><code>Koliko brojeva Å¾elite? 20000
...
BubbleSort
...
Vrijeme: 00:00:02.4718541
...
InsertionSort
...
Vrijeme: 00:00:00.6728540
...
SelectionSort
...
Vrijeme: 00:00:00.9263852
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“—Zadatak: Äitanje iz datoteke" duration="0">
        <h2 is-upgraded><strong>Opis zadatka</strong></h2>
<p>Napravi datoteku koja se sastoji od najmanje 100 string vrijednosti (ili preuzmite sa stranice kolegija).</p>
<p>Sortirajte stringove iz datoteke &#34;po abecedi&#34; upotrebom bubble sort algoritma. Ispisati sortirane podatke.</p>
<h2 is-upgraded><strong>ÄŒitanje iz datoteke</strong></h2>
<p>ÄŒitanje iz <strong>tekstualne</strong> datoteke u C#-u moÅ¾emo implementirati na viÅ¡e naÄina. Dosta je jednostavno koristiti gotove metode koje proÄitaju cijeli sadrÅ¾aj odjednom, kao primjerice metode koje sadrÅ¾i klasa <strong>File</strong>:</p>
<p class="image-container"><img alt="b41348498562d1d9.png" style="width: 251.33px" src="img/b41348498562d1d9.png"></p>
<p>MeÄ‘utim, problem moÅ¾e nastati kad datoteka ima velike koliÄine podataka tako da Äitanje odjednom jako uspori cijeli program. To se neÄ‡e dogoditi ako Äitamo liniju po liniju. Naravno, ako su male koliÄine podataka, onda moÅ¾ete raditi kako vam odgovara.</p>
<p>Ispod je primjer metode za Äitanje podataka iz datoteke liniju po liniju. Potrebno je sljedeÄ‡e:</p>
<ul>
<li>Stvoriti objekt tipa <strong>StreamReader</strong>.</li>
<li>Inicijalno pokuÅ¡ati proÄitati prvu liniju (jer datoteka moÅ¾e biti i prazna), kako bi ispitali moÅ¾emo li krenuti s Äitanjem.</li>
<li>ÄŒitati liniju po liniju.</li>
</ul>
<aside class="warning"><p>ğŸ“Ne zaboravite u tijelu petlje ponovo pozvati Äitanje linije - jer je to uvjet!</p>
</aside>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">static void Citanje(string fileName)
{
    StreamReader sr = new StreamReader(fileName);

    // Äitamo dok ima linija u datoteci
    string linija = sr.ReadLine();
    int br = 0;
    while (linija != null)
    {
        Console.WriteLine(linija);
        linija = sr.ReadLine();
        br++;
    }
    Console.WriteLine(&#34;ProÄitano: &#34; + br);
    sr.Close();
}
</code></pre>
<p>Ovdje vodite raÄuna da je metoda <strong>Citanje()</strong> pisana <strong>unutar Program.cs</strong> te da su elementi klase Program <strong>statiÄki</strong> - kako bi ih mogli pozvati bez instanciranja klase <strong>Program</strong>.</p>
<p>MeÄ‘utim, ako program radi dovoljno brzo i za neku od metoda iz klase <strong>File</strong>, onda moÅ¾ete napisati metodu za Äitanje i ovako:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">static void Citanje2(string fileName)
{
    string[] sve = File.ReadAllLines(fileName);
    foreach (string linija in sve)
    {
        Console.WriteLine(linija);
    }
    Console.WriteLine(&#34;ProÄitano: &#34; + sve.Length);
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“—Zadatak: Sortiranje veÄ‡ sortiranih" duration="0">
        <p>Nizovi podataka koji su veÄ‡ sortirani (ili pribliÅ¾no sortirani) te nizovi podataka koji su obrnuto sortirani od onog Å¡to nam je potrebno su posebni sluÄajevi na koje Ä‡e svaki od naÅ¡a tri spomenuta algoritma drugaÄije reagirati. Uvjerite se sami.</p>
<h2 is-upgraded><strong>Opis zadatka</strong></h2>
<ul>
<li>Napunite niz veÄ‡ sortiranim podacima (cijelim brojevima) koji su poredani od najmanjeg do najveÄ‡eg. Pozovite algoritme sortiranje i izmjerite vrijeme na 10000 cijelih brojeva.</li>
<li>Napunite niz veÄ‡ sortiranim podacima, ali <strong>obrnuto</strong> od onog Å¡to nam treba: od najveÄ‡eg do najmanjeg. Pozovite algoritme sortiranje i izmjerite vrijeme na 10000 cijelih brojeva.</li>
</ul>
<aside class="warning"><p>â“Koji algoritmi su bili najbrÅ¾i?</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="SaÅ¾etak" duration="0">
        <ul>
<li>Implementirali smo vlastitu strukturu podataka u obliku klase u C# koja koristi niz za pohranu podataka.</li>
<li>NauÄili smo koristiti tri osnovna algoritma za sortiranje (BubbleSort, SelectionSort, InsertionSort).</li>
<li>Radili smo s datotekama te sortirali stringove iz tekstualne datoteke.</li>
<li>Upoznali smo se s naÄinima mjerenja vremena izvoÄ‘enja algoritama pomoÄ‡u DateTime, Stopwatch i mjerenja vremena izvrÅ¡avanja procesa.</li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
