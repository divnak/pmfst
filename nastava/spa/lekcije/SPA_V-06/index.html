
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>SPA: VjeÅ¾be 06</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<link rel="stylesheet" href="css/prism-coy-all.css">
<script src="css/prism-coy-all.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="SPA_V-06"
                  title="SPA: VjeÅ¾be 06"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Uvod" duration="0">
        <p>ğŸ“Œ RijeÄnik - Dictionary</p>
<p>ğŸ“Œ RasprÅ¡eno adresiranje - Hashtable</p>
<h2 is-upgraded>RjeÄnici</h2>
<p>Upoznat Ä‡emo strukturu rjeÄnika (eng. dictionary) koja je korisna i Äesto se koristi kod programiranja, a u nastavku teksta Ä‡emo ÄeÅ¡Ä‡e koristiti termin na engleskom jeziku: <strong>dictionary</strong> jednostavno iz razloga jer se tako zove gotova klasa u C#-u koju Ä‡emo koristiti. Svaki element u strukturi dictionary ima <strong>kljuÄ</strong> (eng. key) koji je povezan s <strong>vrijednosti</strong> (eng. value) tog kljuÄa. KljuÄ i vrijednost predstavljaju par.</p>
<p>Analogija je s rjeÄnikom stranih rijeÄi gdje za svaku stranu rijeÄ (kljuÄ) imamo opis ili prijevod (vrijednost).</p>
<aside class="special"><p>KljuÄevi se koriste za dohvaÄ‡anje vrijednosti.</p>
</aside>
<p>Drugi primjer (ilustracija) iz stvarnog Å¾ivota gdje se moÅ¾e vidjeti upotreba spomenute strukture je odlazak u kazaliÅ¡te gdje posjetitelji ostavljaju svoje kapute, a zaposlenik im daje broj. Kad predstava zavrÅ¡i, posjetitelj vraÄ‡a broj (kljuÄ) kojeg zaposlenik koristi kako bi pronaÅ¡ao kaput (vrijednost koja pripada kljuÄu).</p>
<p>Prilikom upotrebe <strong>apstraktne strukture podataka</strong> (eng. abstract data type, ADT) <strong>dictionary</strong> kljuÄ ne mora biti samo broj veÄ‡ moÅ¾e biti bilo koji drugi tip objekta. Ako za kljuÄ koristimo cijeli broj onda implementacija podsjeÄ‡a na strukturu obiÄnog <strong>niza</strong> (eng. array) ili liste (List&lt;T&gt;). MeÄ‘utim, kad koristimo niz ili listu, onda ne moÅ¾emo koristiti proizvoljne indekse veÄ‡ unaprijed zadane koji poÄinju od 0 do n-1 (n predstavlja broj elemenata). Struktura <strong>Dictionary</strong> je prema tome fleksibilnija.</p>
<h2 is-upgraded><strong>RasprÅ¡eno adresiranje</strong></h2>
<p>RasprÅ¡eno adresiranje (eng. hashing) ili hash-iranje je postupak mapiranja veÄ‡ih objekata u manje pomoÄ‡u <strong><em>hash</em></strong> funkcije. Hash funkcija vraÄ‡a odgovarajuÄ‡e <em>hash</em> vrijednosti ili kÃ´dove (kljuÄeve) koje odgovaraju lokaciji gdje se podatak mora spremiti. Taj postupak se koristi u strukturama podataka koje se nazivaju &#34;hash tablice&#34; (eng. hashtable). Ovdje Ä‡emo zadrÅ¾ati engleski termin radi lakÅ¡eg razumijevanja i sliÄnosti s nazivom klase u C#-u.</p>
<p>Hash tablice se koriste za brzo dohvaÄ‡anje podataka, a pomoÄ‡u hash funkcija moÅ¾e se ubrzati otkrivanje duplih zapisa u velikim datotekama ili traÅ¾enje sliÄnih zapisa (npr. pronalaÅ¾enje sliÄnih uzoraka u DNK, sliÄnih podstringova, zapisa u audio datotekama i sl.).</p>
<p>U C#-u koristimo gotovu klasu koje se naziva <strong>Hashtable</strong>.</p>


      </google-codelab-step>
    
      <google-codelab-step label="RjeÄnik / Dictionary" duration="0">
        <p>Dictionary u C#-u predstavlja generiÄku kolekciju koja omoguÄ‡ava pohranjivanje podataka u obliku parova <strong>kljuÄ-vrijednost</strong> (nalazi se u imenskom prostoru <strong>System.Collections.Generic</strong>). Ova struktura podataka je idealna kada Å¾elimo brz pristup podacima koristeÄ‡i jedinstvene kljuÄeve. MoÅ¾emo ga zamisliti sliÄno kao kod rjeÄnika stranih rijeÄi gdje je kljuÄ pojam, a vrijednost njegova definicija. Struktura je vrlo fleksibilna i omoguÄ‡ava razliÄite tipove podataka za kljuÄeve i vrijednosti.</p>
<p>Dictionary se u C# definira kao <strong>Dictionary&lt;TKey, TValue&gt;</strong>, gdje:</p>
<ul>
<li><strong>TKey</strong> predstavlja tip kljuÄa (obiÄno neki od osnovnih tipova kao Å¡to su int, string, char, ...),</li>
<li><strong>TValue</strong> predstavlja tip vrijednosti (moÅ¾e biti bilo koji tip: osnovni tipovi, klase, strukture, itd.).</li>
</ul>
<p>Primjer za rijeÄnik kojem su kljuÄevi tipa string, a vrijednosti cijeli brojevi:</p>
<pre><code>Dictionary&lt;string, int&gt; brojac = new Dictionary&lt;string, int&gt;();
</code></pre>
<p>Ovaj rjeÄnik moÅ¾emo koristiti za brojanje koliko puta se odreÄ‘ene rijeÄi pojavljuju u tekstu, pri Äemu je kljuÄ rijeÄ koju Å¾elimo brojati, a cjelobrojna vrijednost broj ponavljanja.</p>
<aside class="warning"><p><strong>VaÅ¾no:</strong> KljuÄ mora biti jedinstven!</p>
</aside>
<h3 is-upgraded><strong>Primjeri</strong></h3>
<p>PraÄ‡enje zaliha u skladiÅ¡tu:</p>
<ul>
<li>Zamislimo Dictionary u kojem kljuÄevi predstavljaju Å¡ifru proizvoda (ili jedinstvena imena), a vrijednosti koliÄine tih proizvoda.</li>
<li>Npr. zalihe[&#34;Banane&#34;] = 150;</li>
</ul>
<p>Telefonski imenik:</p>
<ul>
<li>U ovom primjeru, kljuÄ je ime i prezime, a vrijednost telefonski broj.</li>
<li>Obzirom da telefonski broj moÅ¾e poÄeti s nulom (Å¡to ne postoji za cijele brojeve), eventualno moÅ¾e sadrÅ¾avati crtice ili razmake te nije podatak s kojim se moraju obavljati aritmetiÄke operacije, onda moÅ¾e takoÄ‘er biti tipa string.</li>
</ul>
<p>TeÄaj:</p>
<ul>
<li>KljuÄ je naziv valute (string, npr. USD, EUR), a vrijednost iznos teÄaja (float ili double, npr. 7.53).</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Osnovne operacije s Dictionary" duration="0">
        <p>Instanciranje, primjer:</p>
<pre><code>Dictionary&lt;string, int&gt; popis = new Dictionary&lt;string, int&gt;();
</code></pre>
<h2 is-upgraded><strong>Dodavanje elemenata</strong></h2>
<p>Dodavanje elemenata (unos u Dictionary) moÅ¾emo obaviti na dva naÄina:</p>
<ul>
<li>PomoÄ‡u metode <strong>Add()</strong>,</li>
<li>PomoÄ‡u uglatih zagrada.</li>
</ul>
<p>Primjenom metode <strong>Add()</strong> moÅ¾e se dogoditi iznimka (greÅ¡ka) ako pokuÅ¡amo dodati par s kljuÄem koji veÄ‡ postoji. Primjenom uglatih zagrada, neÄ‡e se dogoditi greÅ¡ka, veÄ‡ Ä‡e se &#34;pregaziti&#34; postojeÄ‡a vrijednost (ako postoji) ili jednostavno spremiti novi par. Premda se to na prvu Äini kao prednost, teÅ¾e Ä‡emo uoÄiti da vrijednost veÄ‡ postoji (jer neÄ‡emo dobiti nikakvo upozorenje pa je lako previdjeti duplikate).</p>
<pre><code>// spremimo broj ECTS-ova za studente:
popis.Add(&#34;Ana&#34;, 20);
popis.Add(&#34;Pero&#34;, 19);

// drugi naÄin
popis[&#34;Ivo&#34;] = 55;
</code></pre>
<h2 is-upgraded><strong>Pristupanje vrijednostima</strong></h2>
<p>Vrijednosti dohvaÄ‡amo po kljuÄu, npr.:</p>
<pre><code>Console.WriteLine(popis[&#34;Ana&#34;]); // Ispisuje: 20
</code></pre>
<p>Za ispis svih elemenata rjeÄnika moÅ¾emo koristiti <strong>foreach</strong> petlju.</p>
<aside class="warning"><p>PreporuÄuje se iteracija kroz kljuÄeve, jer nam omoguÄ‡ava pristup i kljuÄevima i vrijednostima!</p>
</aside>
<p>Primjer:</p>
<pre><code>foreach (string k in popis.Keys)
{
    Console.WriteLine($&#34;KljuÄ: {k}, ECTS: {popis[k]}&#34;);
}
</code></pre>
<h2 is-upgraded><strong>Provjera postojanja kljuÄa</strong></h2>
<p>Metoda <strong>ContainsKey()</strong> koristi se za provjeru postoji li odreÄ‘eni kljuÄ u rjeÄniku:</p>
<pre><code>if (popis.ContainsKey(&#34;Ana&#34;))
{
    Console.WriteLine(&#34;KljuÄ Ana postoji u rjeÄniku.&#34;);
}
else
{
    // Dodaj Anu
}
</code></pre>
<aside class="special"><p>Provjera duplikata (sadrÅ¾i li struktua kljuÄ kojeg dodajemo) Ä‡e biti vaÅ¾na kod unosa.</p>
<p>Upravljanje duplikatima ukljuÄuje:</p>
<p>âœ… Provjeru kod unosa (hoÄ‡e li se zadrÅ¾ati postojeÄ‡a vrijednost ili pregaziti novom)</p>
<p>âœ… Brojanje ili ispis duplih podataka.</p>
</aside>
<h2 is-upgraded><strong>Brisanje elemenata</strong></h2>
<p>Elemente iz rjeÄnika briÅ¡emo pomoÄ‡u metode <strong>Remove()</strong> i kljuÄa:</p>
<pre><code>popis.Remove(&#34;Ana&#34;);
</code></pre>
<p>Ako znamo koji kljuÄ briÅ¡emo, onda je brisanje jednostavno i brzo.</p>
<h2 is-upgraded><strong>Brisanje viÅ¡e elemenata iz strukture Dictionary</strong></h2>
<p>Brisanje jedne vrijednosti po kljuÄu je jednostavno, ali Äesto se zna dogoditi da nam treba brisanje viÅ¡e vrijednosti. Taktika za brisanje provodi se u dva koraka (a ideju moÅ¾emo koristiti i za druge strukture):</p>
<ol type="1">
<li>ProÄ‡i kroz sve elemente te u poseban popis prikupiti kljuÄeve od onih elemenata koji zadovoljavaju postavljeni uvjet (koje Å¾elimo brisati).</li>
<li>ProÄ‡i kroz popis za brisanje i pobrisati elemente koje smo spremili.</li>
</ol>
<p>Neka je zadana klasa <strong>Student</strong>:</p>
<p><code>Student.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace dict
{
    class Student
    {
        public string imePrezime;
        public string jmbag;
        public Student(string ip, string jm)
        {
            this.imePrezime = ip;
            this.jmbag = jm;
        }
    }
}
</code></pre>
<p>U glavnom dijelu programa Ä‡emo upisati par elemenata te pobrisati sve kojima ime poÄinje slovom â€˜A&#39;. InaÄe, Jmbag je uvijek jedinstven za sve studente pa Ä‡emo ga odabrati kao kljuÄ, a kako moÅ¾e poÄeti s nulom i nema raÄunanja s njim, onda Ä‡e isto biti string.</p>
<p>Napravimo primjer s par podataka za unos i ispis:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace dict;

class Program
{
    static void Main(string[] args)
    {
        // deklaracija i inicijalizacija
        Dictionary&lt;string, Student&gt; popis = new Dictionary&lt;string, Student&gt;();

        // unos (pazite, ne provjeravamo postoji li!)
        // inaÄe je ovo praktiÄnije Äitati iz datoteke
        Student a = new Student(&#34;Ana&#34;, &#34;0123&#34;);
        Student b = new Student(&#34;Pero&#34;, &#34;4567&#34;);
        Student c = new Student(&#34;Ante&#34;, &#34;7890&#34;);
        popis.Add(a.jmbag, a);
        popis.Add(b.jmbag, b);
        popis.Add(c.jmbag, c);

        // ispis
        foreach (string k in popis.Keys)
        {
            Console.WriteLine($&#34;Jmbag: {popis[k].jmbag}, {popis[k].imePrezime}&#34;);
        }

    }
}
</code></pre>
<p>Zatim slijedi brisanje. U prvoj fazi koristimo <strong>List&lt;&gt;</strong> jer je dinamiÄka i ne znamo koliko Ä‡e biti kandidata za brisanje svoj koji zadovoljavaju uvjet:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">// brisanje
// 1. faza - skupljanje kljuÄeva
List&lt;string&gt; brisanje = new List&lt;string&gt;();
foreach (string k in popis.Keys)
{
    Student s = popis[k];
    if (s.imePrezime[0] == &#39;A&#39;)
        brisanje.Add(k);
}

// 2. faza - brisanje
foreach (string k in brisanje)
{
    popis.Remove(k);
}
</code></pre>
<aside class="warning"><p>â€‹â€‹ğŸ“ Ako se ne naÄ‘e ni jedan element koji zadovoljava uvjet, onda Ä‡e lista kljuÄeva za brisanje biti prazna tako da se druga faza neÄ‡e nikad izvrÅ¡iti.</p>
<p>ğŸ“ Petlja <strong>foreach</strong> ne dozvoljava izmjene strukture po kojoj <em>iterira</em> tijekom izvrÅ¡avanja, ali u gornjim fazama to nije sluÄaj.</p>
</aside>
<p>IspiÅ¡ite stanje nakon brisanja kako bi provjerili je li stvarno pobrisano.</p>
<h2 is-upgraded><strong>SliÄne strukture</strong></h2>
<p>U C# programskom jeziku postoje razliÄite implementacije strukture rjeÄnika. Klasa <strong>SortedDictionary&lt;TKey, TValue&gt;</strong> je implementacija rjeÄnika koja ima automatski sortirane kljuÄeve, a inaÄe elemente gotove klase Dictionary nije moguÄ‡e sortirati. TehniÄki je implementirana pomoÄ‡u stabala (koje Ä‡emo uÄiti kasnije), ali to nas trenutno ne zanima je je koristimo bez poznavanja unutarnje strukture. PraktiÄan problem kojeg moÅ¾emo rijeÅ¡iti uz pomoÄ‡ ove strukture je na primjer:</p>
<p><strong>Zadatak</strong>: PronaÄ‘ite sve razliÄite rijeÄi u tekstu. IspiÅ¡ite ih bez ponavljanja poredane po abecedi. IspiÅ¡ite koliko se puta svaka rijeÄ pojavljuje u tekstu.</p>
<p>Klasa <strong>SortedList&lt;TKey, TValue&gt;</strong> je sliÄna prethodno spomenutoj klasi, ali za razliku od nje koristi niz (array) za implementaciju. <strong>SortedList</strong> teoretski zauzima manje memorije od SortedDictionary koja omoguÄ‡uje brÅ¾e umetanje i brisanje. Te razlike se neÄ‡e previÅ¡e</p>
<p>primijetiti kod zadataka na vjeÅ¾bama.</p>
<aside class="special"><p>âœ… Probajte koristiti SortedList i/ili SortedDictionary!</p>
<p>âœ… U nekim situacijama ih je bolje koristiti u odnosu na obiÄni Dictionary.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Hashtable klasa" duration="0">
        <p>Klasa <strong>Hashtable</strong> nalazi se u imenskom prostoru <strong>System.Collections</strong>. Na prvi pogled se Äini jako sliÄna kod primjene kao <strong>Dictionary</strong>, ali ipak postoje neke sitne razlike. OpÄ‡enito, iza rasprÅ¡enog adresiranja postoji dosta teorije (pogotovo ako bi sami implementirali vlastitu klasu). Poseban problem je rjeÅ¡avanje kolizije. Kod primjene gotove <strong>Hashtable</strong> klase, vodimo samo raÄuna o tome kako primijeniti osnovne operacije unosa, dohvaÄ‡anja podataka, brisanja i traÅ¾enja.</p>
<p>Ono Å¡to je ovdje vaÅ¾no jest primijetiti razliku u deklaraciji klasa:</p>
<ul>
<li>Dictionary&lt;TKey, TValue&gt;</li>
<li>Hashtable</li>
</ul>
<p>PrimjeÄ‡ujemo kako <strong>Hashtable</strong> nema tip, Å¡to znaÄi da u tu klasu moÅ¾emo spremati bilo kakve elemente i mijeÅ¡ati podatke razliÄitih tipova.</p>
<aside class="warning"><p>ğŸ“ Svi elementi popisa tipa <strong>Hashtable</strong> su tipa <strong>object</strong>.</p>
</aside>
<h2 is-upgraded><strong>Tip object</strong></h2>
<p>Tip <strong>object</strong> u predstavlja osnovni, generiÄki tip podataka u .NET-u koji moÅ¾e prihvatiti vrijednosti bilo kojeg drugog tipa, jer su svi ostali tipovi zapravo izvedeni iz <strong>object</strong>. Kada koristimo <strong>object</strong> kao tip, to znaÄi da varijabla moÅ¾e primiti bilo koji tip podatka, ukljuÄujuÄ‡i osnovne tipove kao Å¡to su int, string, bool, kao i sloÅ¾ene tipove poput klasa i struktura.</p>
<p>Kada koristiti object kao tip? Ima smisla u sljedeÄ‡im situacijama:</p>
<ul>
<li>Podaci su raznovrsni - kad trebate pohraniti razliÄite vrste podataka u jednoj strukturi</li>
<li>Potrebna fleksibilnost - kad ne znate unaprijed sve vrste podataka koje Ä‡e kolekcija sadrÅ¾avati.</li>
<li>GeneriÄka implementacija - kad sami piÅ¡ete generiÄku strukturu ili vam treba funkcionalnost koja mora podrÅ¾avati razliÄite tipove podataka.</li>
</ul>
<p>Lako se moÅ¾e dogoditi greÅ¡ka pri izvrÅ¡avanju programa ako tip podataka nije ono Å¡to oÄekujemo.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Osnovne operacije s Hashtable" duration="0">
        <p>Za klasu <strong>Hashtable</strong> vrijedi kao za <strong>Dictionary</strong> u sljedeÄ‡im situacijama (iz prethodnog dijela):</p>
<ul>
<li>Dodavanje elemenata</li>
<li>Pristupanje vrijednostima pomoÄ‡u uglatih zagrada</li>
</ul>
<p>U strukturu jednostavno moÅ¾emo spremiti sve, no problem se javlja kad Äitamo. Ako su podaci jednostavnog osnovnog tipa (kao Å¡to su string, int, double i sl.) i ako ih samo ispisujemo, onda Ä‡e se dogoditi automatsko pretvaranje (konverzija) tipova u string tako da neÄ‡emi primijetiti razliku. MeÄ‘utim, problem se javlja Äim moramo obavljati operacije koje su definirane za konkretan tip (npr. Zbrajanje, oduzimanje, ...) ili ako se radi o sloÅ¾enim tipovima kao Å¡to su klase (jer ih neÄ‡emo moÄ‡i ispisati).</p>
<p>Pogledajmo na primjeru. Neka je zadana klasa <strong>Radnik</strong>:</p>
<p><code>Radnik.cs</code></p>
<pre><code language="language-cs" class="language-cs">namespace HT_Primjer
{
    class Radnik
    {
        public string ime;
        public double placa;

        public Radnik(string im, double p)
        {
            this.ime = im;
            this.placa = p;
        }
    }
}
</code></pre>
<p>Pripremite tekstualnu datoteku s par radnika za probu, npr.:</p>
<pre><code>pero;1250,15
ana;4500,10
maja;785,45
</code></pre>
<p>U glavnom dijelu programa Ä‡emo upisati i ispisati podatke:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Collections;
using System.IO;

namespace HT_Primjer;
class Program
{
    static void Main(string[] args)
    {
        Console.Write(&#34;Datoteka: &#34;);
        string imeDat = Console.ReadLine();

        if(!File.Exists(imeDat))
        {
            Console.WriteLine(&#34;Datoteka ne postoji!&#34;);
            return;
        }

        Hashtable ht = new Hashtable();

        using (StreamReader sr = new StreamReader(imeDat))
        {
            string linija;
            while ((linija = sr.ReadLine()) != null)
            {
                // rastavi
                string[] s = linija.Split(&#39;;&#39;);
                //pero;1250,15
                double p = double.Parse(s[1]);
                Radnik novi = new Radnik(s[0], p);
                if(!ht.ContainsKey(novi.ime))
                {
                    ht.Add(novi.ime, novi);
                }
            }
            Console.WriteLine(&#34;Upisano: &#34; + ht.Count);
            // ispis
            foreach (string k in ht.Keys)
            {
                Radnik r = (Radnik)ht[k]; // OVO JE VAÅ½NO!
                Console.WriteLine($&#34;Ime: {r.ime}, PlaÄ‡a: {r.placa}&#34;);
            }
        }
    }
}
</code></pre>
<p>Premda ima viÅ¡e naÄina za pretvorbu, ono Å¡to uvijek radi u ovim situacijama je <strong>cast</strong> operator.</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Alice - brojanje rijeÄi" duration="0">
        <p>Napisati konzolsku aplikaciju koja Ä‡e proÄitati tekstualnu datoteku <strong>alice.txt</strong>, prebrojati i ispisati koliko puta se svaka rijeÄ pojavljuje u tekstu. Upute:</p>
<ul>
<li>Koristiti dictionary ili hash tablice</li>
<li>Ispisati koja se rijeÄ najÄeÅ¡Ä‡e pojavljuje (RjeÅ¡enje: the se pojavljuje 1643 puta).</li>
<li>Ispisati koliko puta se pojavljuje rijeÄ <strong>and</strong> (RjeÅ¡enje: and se pojavljuje 872 puta).</li>
</ul>
<p>VaÅ¾no je pretvoriti sve linije teksta koje proÄitate iz datoteke u velika ili mala slova primjenom metode <strong>ToLower()</strong> ili <strong>ToUpper()</strong>.</p>
<pre><code>string[] rijeci = linija.ToLower().Split();
</code></pre>
<p>Nakon Å¡to se linija teksta pretvori u mala slova, potrebno je tu liniju rastaviti na rijeÄi. Ako ostavimo kao u gornjem primjeru, metoda <strong>Split()</strong> Ä‡e rastaviti liniju na rijeÄi koristeÄ‡i samo razmake (zadana vrijednost). MeÄ‘utim, znamo da to nije ni pribliÅ¾no dovoljno jer ima viÅ¡e drugih znakova koje ne smatramo dijelom rijeÄi. Ako Ä‡emo koristiti englesku abecedu (jer je Alice datoteka pisana na engleskom jeziku), onda Ä‡emo za potrebe ovog zadatka zanemariti sve znakove osim slova.</p>
<p>Ukupno znamo da imamo ASCII tablicu od 256 znakova. Unicode ima i viÅ¡e, ali kako nemamo nikakve druge posebne znakove, onda nam je ova tablica dovoljna. Napravit Ä‡emo novi niz znakova (char) od 256 elemenata (da, malo je viÅ¡e od potrebnog, ali elementi koji nam ostanu nula Ä‡e se svakako ignorirati). Iteracijom po tim znakovima provjerit Ä‡emo koji od njih je slovo te sve ostale znakove spremiti u niz separatora.</p>
<p class="image-container"><img alt="img\\\\cc04e665fbee2f77.png" style="width: 293.40px" src="img\\cc04e665fbee2f77.png"></p>
<p>U gornjem primjeru, u liniji gdje je naredba <strong>if</strong> opet vidimo <strong>cast</strong> operator. Koristimo ga jer nam je (po navici) iterator (varijabla <strong>a</strong>) tipa <strong>int</strong> pa je moramo pretvoriti u <strong>char</strong>.</p>
<p>Mogli smo koristiti listu tako da nam ne bude viÅ¡ka elemenata niza, ali u tom sluÄaju bi morali u nekom trenutku pozvati metodu <strong>ToArray()</strong> jer <strong>Split()</strong> prima niz.</p>
<aside class="warning"><p><strong>Napomena:</strong> U kolokvijima i ispitima neÄ‡e biti potrebno traÅ¾iti sve moguÄ‡e separatore.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: RjeÄnik pojmova" duration="0">
        <p>Napisati aplikaciju koja Ä‡e uÄitati podatke iz tekstualne datoteke:</p>
<ul>
<li>tipovi_podataka.csv</li>
<li>Datoteka se sastoji od parova odvojenih toÄka-zarezom ;</li>
</ul>
<p>Podaci:</p>
<ul>
<li>Naziv tipa</li>
<li>Opis tipa</li>
</ul>
<p>Potrebno je ispisati sve nazive tipova koji su u datoteci. Zatim korisnik unosi naziv nekog od tipova za koji Å¾eli znati dodatne informacije.</p>
<ul>
<li>Ako tip postoji, ispisat Ä‡e se opis, a</li>
<li>Ako ne postoji, onda Ä‡e se ispisati poruka &#34;Ne postoji!&#34;</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: RjeÅ¡avanje kolizije *" duration="0">
        <p>Napraviti program koji Ä‡e proÄitati iz datoteke:</p>
<ul>
<li>Ime studenta</li>
<li>Studijsku grupu (MI, INF, MAT, IT, FI) = 5 grupa</li>
<li>Godinu studija (1-3)</li>
</ul>
<p>Korisnik unosi studijsku grupu i godinu studija, a program ispisuje sve studente za odabrane podatke.</p>
<p>Ovdje Ä‡emo napraviti vlastitu strukturu podataka koja radi po principu <em>hash</em> tablice s rjeÅ¡avanjem kolizije (postupkom ulanÄavanja). U ovom sluÄaju namjerno radimo kolizije kako bi svi podaci koji pripadaju istom kljuÄu bili na istom mjestu.</p>
<ul>
<li>Napraviti svoju strukturu podataka koja Ä‡e imati 15 polja.</li>
<li>KljuÄ za svako od tih polja je napravljen na temelju grupe i godine (npr. moÅ¾e se spojiti INF2).</li>
<li>Dozvoljene su kolizije (viÅ¡e studenata na INF2), koje moÅ¾ete rijeÅ¡iti kako Å¾elite.</li>
</ul>
<p>(kao Å¡to je bilo na predavanjima)</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
