
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>SPA: NasljeÄ‘ivanje</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
<link rel="stylesheet" href="css/prism-coy-all.css">
<script src="css/prism-coy-all.js"></script>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="SPA_V-05"
                  title="SPA: NasljeÄ‘ivanje"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Uvod" duration="0">
        <p>ğŸ“Œ NasljeÄ‘ivanje i nadogradnja klasa u .NET/C# okruÅ¾enju</p>
<h2 is-upgraded>Uvod u nasljeÄ‘ivanje</h2>
<p>NasljeÄ‘ivanje je jedan od temeljnih pojmova objektno orijentiranog programiranja (OOP), koji omoguÄ‡ava jednoj klasi nasljeÄ‘ivanje svojstava i metoda druge klase. Ovo znaÄi da klasa koja nasljeÄ‘uje (nazivamo je <em>podklasa</em> ili <em>izvedena klasa</em>), moÅ¾e koristiti sve javne (<strong>public</strong>) i zaÅ¡tiÄ‡ene (<strong>protected</strong>) metode, varijable i svojstva klase koju nasljeÄ‘uje. Klasa od koje nasljeÄ‘uje naziva se <strong>osnovna</strong> ili <em>superklasa</em>.</p>
<p>U praksi, nasljeÄ‘ivanje omoguÄ‡uje ponovnu upotrebu postojeÄ‡eg kÃ´da, Å¡to ubrzava razvoj i smanjuje potrebu za pisanjem kÃ´da koji se ponavlja. Umjesto pisanja nove klase od nule svaki put kada nam je potrebna sliÄna funkcionalnost, moÅ¾emo stvoriti novu klasu koja nasljeÄ‘uje sve elemente postojeÄ‡e klase, a zatim dodati specifiÄne funkcionalnosti koje su nam potrebne.</p>
<aside class="special"><p><strong>Napomena:</strong> Na kolegiju Strukture podataka i algoritmi (SPA), nasljeÄ‘ivanje koristimo na neÅ¡to jednostavniji naÄin, s naglaskom na nadogradnju postojeÄ‡ih klasa i dodavanje funkcionalnosti bez detaljne analize ostalih koncepata OOP-a.</p>
</aside>
<p>Primjeri koje koristimo mogu ukljuÄivati metode za ispis podataka, pretragu i sliÄne osnovne funkcionalnosti koje olakÅ¡avaju rad sa strukturama podataka za naÅ¡e potrebe, a nisu veÄ‡ ukljuÄene u postojeÄ‡u implementaciju.</p>
<aside class="warning"><p><strong>Napomena</strong>: Na kolegiju Objektno orijentirano programiranje (OOP) detaljnije Ä‡ete raditi nasljeÄ‘ivanje i razmatrati sloÅ¾enije primjere. Tamo Ä‡ete vidjeti kako moÅ¾ete stvarati sloÅ¾enije hijerarhije klasa i proÅ¡irivati gotove strukture s obzirom na specifiÄne zahtjeve. Ovdje Ä‡emo se, meÄ‘utim, fokusirati na jednostavniju primjenu nasljeÄ‘ivanja u kontekstu struktura podataka.</p>
</aside>
<p>U <em>nadogradnji</em> postojeÄ‡ih klasa cilj je koristiti veÄ‡inu gotovih moguÄ‡nosti neke klase, poput metoda Add(), Clear() i sliÄnih, dok se samo dodaju odreÄ‘ene funkcionalnosti prema specifiÄnim potrebama zadatka. Tako se Å¡tedi vrijeme i omoguÄ‡ava uÄinkovitije upravljanje kÃ´dom, bez dodatne sloÅ¾enosti koja bi nastala kod ruÄnog pisanja svake klase od poÄetka.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Kako &#34;nadograditi&#34; gotove klase?" duration="0">
        <p>Kada Å¾elimo proÅ¡iriti funkcionalnost neke veÄ‡ gotove klase, nasljeÄ‘ivanje nam omoguÄ‡uje da to uÄinimo na jednostavan i efikasan naÄin. Umjesto stvaranje potpuno nove klase koja implementira iste funkcionalnosti kao postojeÄ‡a klasa, moÅ¾emo stvoriti novu klasu koja nasljeÄ‘uje postojeÄ‡u, a zatim dodati samo one metode koje su specifiÄne za naÅ¡e potrebe.</p>
<p>Razmotrimo primjer s klasom <strong>Queue</strong> u .NET/C# okruÅ¾enju. Klasa Queue predstavlja strukturu podataka koja pohranjuje elemente u obliku reda - prvi uneseni element je prvi koji Ä‡e biti uklonjen (princip &#34;prvi uÅ¡ao, prvi izaÅ¡ao&#34; ili FIFO). Ova klasa dolazi s veÄ‡ definiranim metodama, poput:</p>
<ul>
<li><strong>Enqueue()</strong> - dodavanje elemenata na kraj reda i</li>
<li><strong>Dequeue()</strong> - uklanjanje elemenata s poÄetka reda,</li>
</ul>
<p>koje omoguÄ‡uju osnovne operacije nad redom.</p>
<p>MeÄ‘utim, nama je potrebno proÅ¡iriti funkcionalnost klase <strong>Queue</strong> jer Å¾elimo ispisati sve element na konzolu. Umjesto pisanja nove klase (kao Å¡to smo to radili na prvim vjeÅ¾bama), moÅ¾emo stvoriti klasu koja nasljeÄ‘uje Queue ili Äak <strong>Queue&lt;int&gt;</strong> i zatim dodati vlastitu metodu za ispis elemenata.</p>
<p>U ovom sluÄaju, kreirat Ä‡emo klasu <strong>MojQBrojeva</strong> koja nasljeÄ‘uje sve funkcionalnosti generiÄke klase <strong>Queue&lt;int&gt;</strong>, a zatim Ä‡emo dodati novu metodu pod nazivom <strong>Ispis()</strong>. Metoda Ispis() Ä‡e iterirati kroz sve elemente reda i ispisati ih na konzolu, Äime Ä‡emo dobiti moguÄ‡nost prikaza sadrÅ¾aja reda bez potrebe za dodatnim ruÄnim pristupom elementima.</p>
<p>Evo kako bi izgledala implementacija takve klase:</p>
<p><code>MojQBrojeva.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Collections.Generic;

public class MojQBrojeva : Queue&lt;int&gt;
{
    // Dodana metoda za ispis elemenata reda
    public void Ispis()
    {
        foreach (int broj in this)
        {
            Console.WriteLine(broj);
        }
    }
}
</code></pre>
<aside class="warning"><p><strong>Napomena:</strong> U implementaciji metode za ispis koristimo posebnost gotove klase Queue koja dozvoljava iteriranje po elementima reda pomoÄ‡u petlje!</p>
</aside>
<p>To nam je ponekad potrebno, ali nije opÄ‡enito osobina strukture reda jer bi teoretski trebao biti omoguÄ‡en samo pristup poÄetnom elementu. U klasama i metodama koje smo radili na poÄetnim vjeÅ¾bama to nije bilo moguÄ‡e, ali ovdje ne Å¾elimo pisati sve iz poÄetka veÄ‡ Ä‡emo koristiti ono Å¡to nam nudi gotova klasa.</p>
<p>U glavnom dijelu programa moÅ¾emo primijeniti novu klasu i metodu na sljedeÄ‡i naÄin:</p>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;

namespace Primjer_MojQ;
class Program
{
    static void Main(string[] args)
    {
        int n = 5;
        
        MojQBrojeva red = new MojQBrojeva();

        for (int i = 0; i &lt; n; i++)
        {
            red.Enqueue(i);
        }

        red.Ispis();
    }
}
</code></pre>
<p>U gornjem primjeru, u petlji <strong>for</strong> unosimo brojeve od 0 do 4 u red. Klasa <strong>Queue&lt;T&gt;</strong> nema metodu za ispis te koristimo naÅ¡u &#34;nadograÄ‘enu&#34; klasu <strong>MojQBrojeva</strong> koja ispisuje elemente reda na konzolu.</p>
<p>Dakle, umjesto instanciranja gotove klase, instanciramo naÅ¡u te pozivamo metodu <strong>Enqueue()</strong> koja je naslijeÄ‘ena i novu metodu <strong>Ispis()</strong> koja postoji samo u naÅ¡oj novoj klasi. Metoda <em>Ispis()</em> neÄ‡e izbaciti elemente iz reda veÄ‡ ih samo ispisuje na konzolu.</p>
<p>Ispis:</p>
<pre><code>0
1
2
3
4
</code></pre>
<p>Klasa <strong>Queue&lt;T&gt;</strong> ima i metodu <strong>ToArray()</strong> koje pretvara red u obiÄan niz. Pri tome dobijemo kopiju elemenata reda:</p>
<p><code>MojQBrojeva.cs</code></p>
<pre><code language="language-cs" class="language-cs">public void Ispis2()
{
    // koristimo metodu ToArray() za pretvaranje u niz
    int[] niz = this.ToArray();
    Console.WriteLine(&#34;Ispis reda:&#34;);
    foreach (int element in niz)
    {
        Console.Write(&#34;{0} &#34;, element);
    }
    // prijelaz u novu liniju teksta
    Console.WriteLine();
}
</code></pre>
<p>U gornjoj metodi smo se dodatno prisjetili formatiranog ispisa. U prethodnoj metodi smo pomoÄ‡u petlje <strong>foreach</strong> izravno pristupali originalnim elementima.</p>
<h2 is-upgraded><strong>Primjer rjeÅ¡enja bez &#34;nadogradnje&#34;</strong></h2>
<p>Naravno da nije nuÅ¾no koristiti &#34;nadogradnju&#34;, ali je korisno jer je kÃ´d Äesto pregledniji te ga moÅ¾emo koristiti u viÅ¡e programa. Ovdje Ä‡emo vidjeti rjeÅ¡enje prethodnog primjera bez nadogradnje. Obratite paÅ¾nju na primjenu kljuÄne rijeÄi <strong>this</strong> u primjeru s nadogradnjom. Moramo voditi raÄuna o sljedeÄ‡em:</p>
<ul>
<li>Sve metode koje se piÅ¡u u klasi <strong>Program</strong> moraju biti <strong>statiÄke</strong> kao Å¡to je to i metoda <strong>Main()</strong>.</li>
<li>U ovom primjeru, metoda <strong>Ispis3()</strong> nema pristup elementima reda, pa prema tome mora <strong>primiti</strong> parametar koji je tipa <strong>Queue&lt;int&gt;</strong> te koristiti instancu (objekt) kojeg je primila.</li>
</ul>
<p><code>Program.cs</code></p>
<pre><code language="language-cs" class="language-cs">using System;
using System.Collections.Generic;

namespace Primjer_MojQ;
class Program
{
    static void Ispis3(Queue&lt;int&gt; r)
    {
        foreach (int element in r)
        {
            Console.WriteLine(element);
        }
    }
    static void Main(string[] args)
    {
        int n = 5;
        
        Queue&lt;int&gt; red = new Queue&lt;int&gt;();

        for (int i = 0; i &lt; n; i++)
        {
            red.Enqueue(i);
        }

        // red.Ispis();
        Ispis3(red);
    }
}
</code></pre>
<aside class="warning"><p>Primijetite:</p>
<ul>
<li>Metoda <strong>Ispis3()</strong> ne priprada klasi <strong>Queue&lt;int&gt;,</strong> prima objekt <strong>red</strong> te ispisuje elemente tog objekta.</li>
<li>Metoda <strong>Ispis()</strong> pripada klasi <strong>MojQBrojeva</strong> te ispisuje elemente iz reda referencirajuÄ‡i ih unutar klase pomoÄ‡u kljuÄne rijeÄi <strong>this</strong>.</li>
</ul>
</aside>
<p>Å to je bolje koristiti? Ovisi o zadatku kojeg rjeÅ¡avamo i eventualnoj buduÄ‡oj primjeni postojeÄ‡eg kÃ´da. Ako u vaÅ¡em zadatku na ispitu piÅ¡e &#34;nadogradi postojeÄ‡u klasu&#34; onda <strong>se neÄ‡e priznati rjeÅ¡enje</strong> sa statiÄkom metodom u glavnom dijelu programa!</p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Vezana lista" duration="0">
        <ul>
<li>Napisati program za upis studenata na prvu godinu i formiranje rang liste.</li>
<li>Koristiti vezanu listu (moÅ¾e se koristiti vlastita ili LinkedList)</li>
</ul>
<p>Unose se sljedeÄ‡i podaci:</p>
<ul>
<li>Ime i prezime studenta</li>
<li>Studijska grupa (MI, INF, ...)</li>
<li>Broj bodova ostvaren na maturi</li>
</ul>
<p>Nakon unosa ispravnih podataka, svaki student se sprema na kraj liste.</p>
<p>Dodatno omoguÄ‡iti:</p>
<ul>
<li>Spremanje unesenih studenata u datoteku</li>
<li>UÄitavanje podataka o studentima iz datoteke</li>
</ul>
<h2 is-upgraded><strong>Izbornik</strong></h2>
<p class="image-container"><img alt="img\\\\b8f6b8548d70c7ea.png" style="width: 241.50px" src="img\\b8f6b8548d70c7ea.png"></p>
<p>Unos podataka</p>
<ul>
<li>unos svih podataka o studentu pomoÄ‡u konzole</li>
<li>statiÄka metoda Unos() - ne prima niÅ¡ta, vraÄ‡a 1 studenta</li>
</ul>
<p>Spremi u datoteku</p>
<ul>
<li>statiÄka metoda Spremi() - prima vezanu listu, ne vraÄ‡a niÅ¡ta</li>
<li>sprema podatke iz vezane liste u datoteku odvojene s #</li>
</ul>
<p>UÄitaj iz datoteke</p>
<ul>
<li>statiÄka metoda Ucitaj() - prima vezanu listu, ne vraÄ‡a niÅ¡ta</li>
<li>uÄitava podatke odvojene s # iz datoteke u vezanu listu</li>
</ul>
<p>Kraj</p>
<ul>
<li>Program prestaje raditi</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Nova metoda AddSort()" duration="0">
        <ul>
<li>Dodajte metodu <strong>AddSort()</strong> koja Ä‡e dodati upisanog studenta sortirano (prema broju bodova) tako da se automatski formira rang lista (bez koriÅ¡tenja algoritama sortiranja)</li>
<li>Odabirom opcije UÄitaj, podaci se uÄitavaju iz datoteke u listu uz pomoÄ‡ nove <strong>AddSort()</strong> metode.</li>
</ul>
<p class="image-container"><img alt="img\\\\77c122512a8113c5.png" style="width: 262.50px" src="img\\77c122512a8113c5.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Brisanje" duration="0">
        <p>Dodati opciju <strong>BriÅ¡i sve</strong> u izbornik.</p>
<ul>
<li>Odabirom opcije, briÅ¡e se sadrÅ¾aj cijele liste.</li>
</ul>
<p>Dodati opciju <strong>BriÅ¡i 1</strong>:</p>
<ul>
<li>Pitati korisnika da unese redni broj od 1 do n (u skladu s ispisom)</li>
<li>Ako se unese redni broj koji ne postoji, ispisati poruku &#34;Broj ne postoji&#34;</li>
<li>Ako postoji redni broj, onda je potrebno izbrisati odabrani element iz vezane liste.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="ğŸ“— Zadatak: Raspored pacijenata za pregled" duration="0">
        <ul>
<li>Za one koji Å¾ele viÅ¡e</li>
</ul>
<p>Napraviti aplikaciju koja Ä‡e rasporediti pacijente za pregled.</p>
<p>Upute:</p>
<ul>
<li>Popis se nalazi u datoteci popis_pacijenata.csv prema redoslijedu prijava.</li>
<li>Pacijenti imaju pored imena (odvojeno s ; ) i razinu hitnosti.</li>
</ul>
<p>Hitnost:</p>
<ul>
<li>OznaÄena je brojevima od 1-10, s tim da manji broj znaÄi hitnije.</li>
<li>Ako su iste razine, onda na red dolazi pacijent koji se prije prijavio.</li>
</ul>
<p>Napraviti i ispisati raspored poÄevÅ¡i od sutra pod uvjetom:</p>
<ul>
<li>Ordinacija radi svaki dan od 8-16</li>
<li>Za svakog pacijenta treba 15 minuta</li>
</ul>
<h2 is-upgraded><strong>Izgled ispisa</strong></h2>
<p class="image-container"><img alt="img\\\\8ec4607f73c631b0.png" style="width: 217.11px" src="img\\8ec4607f73c631b0.png"></p>
<p>Ili:</p>
<p class="image-container"><img alt="img\\\\3bc1da140c65fc42.png" style="width: 276.35px" src="img\\3bc1da140c65fc42.png"></p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
